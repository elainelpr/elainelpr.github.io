<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C Plus Plus Interview Note</title>
    <url>/2022/01/05/C-Plus-Plus-Interview-Note/</url>
    <content><![CDATA[<font size=4>
<font face="Times New Roman">


<h1 id="1-C-简介"><a href="#1-C-简介" class="headerlink" title="1 C++ 简介"></a>1 C++ 简介</h1><ol>
<li>C++是面向对象的程序设计， 有四个基本特点</li>
</ol>
<ul>
<li>封装</li>
<li>继承</li>
<li>抽象</li>
<li>多态</li>
</ul>
<ol start="2">
<li>C++是对象的集合，每个对象之间通过调用彼此的方法进行交互</li>
</ol>
<ul>
<li>类<blockquote>
<p>类是创建对象的模板，一个类可以创建多个对象。它是一种<font size=5>复杂的数据类型</font>的声明，<font color=red>不占用内存空间,因此在定义类时，不能对成员变量初始化，只有在创建对象以后才能为成员变量赋值</font></p>
</blockquote>
</li>
<li>对象<blockquote>
<p>对象是类的实例，每个对象都是类类型的变量。每个对象都有类的成员变量和成员函数。通过类的实例化创建对象，对象占用空间。</p>
</blockquote>
</li>
<li>成员变量<blockquote>
<p>类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存</p>
</blockquote>
</li>
<li>成员函数<blockquote>
<p>类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，作用范围是全局的，或位于某个命名空间内</p>
</blockquote>
</li>
</ul>
<h1 id="2-Const"><a href="#2-Const" class="headerlink" title="2  Const"></a>2  Const</h1><h2 id="2-1-const的含义"><a href="#2-1-const的含义" class="headerlink" title="2.1 const的含义"></a>2.1 const的含义</h2><p>如果变量前有const， 则该变量不能被改变</p>
<h2 id="2-2-const的作用"><a href="#2-2-const的作用" class="headerlink" title="2.2 const的作用"></a>2.2 const的作用</h2><ul>
<li>防止编程中犯错：改变不应该改变的量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i=<span class="number">100</span>;</span><br><span class="line">i=<span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></li>
<li>定义常量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li>节约内存空间<ul>
<li>const 与define的区别<ol>
<li>define 在预编译阶段展开， const在运行阶段使用</li>
<li>define没有类型。const有具体类型， 在编译时会进行类型检查。</li>
<li>const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-const对象默认为文件的局部变量"><a href="#2-3-const对象默认为文件的局部变量" class="headerlink" title="2.3 const对象默认为文件的局部变量"></a>2.3 const对象默认为文件的局部变量</h2><p>在file2中访问file1的变量，在file2的变量前加extern即可。<br>而const声明的变量只是当前文件中的局部变量</p>
<ul>
<li><p>访问未被const修饰的变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file 1.cpp</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">//file 2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure></li>
<li><p>被const修饰的变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file 1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//file 2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>conclude: 由const定义的变量在定义时需要被初始化; 如果想在其他文件中使用该量，则需要在定义时声明extern</p>
</blockquote>
<h2 id="2-4-const与指针"><a href="#2-4-const与指针" class="headerlink" title="2.4 const与指针"></a>2.4 const与指针</h2><p>有三种类型</p>
<h3 id="2-4-1-指向常量的指针"><a href="#2-4-1-指向常量的指针" class="headerlink" title="2.4.1 指向常量的指针"></a>2.4.1 指向常量的指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;x;  <span class="comment">//声明时可以不初始化：const int p -&gt; legal</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p=&amp;x;</span><br></pre></td></tr></table></figure>
<p>p指向一个int 类型的变量，不能改变该变量的值。但是可以改变p指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y=<span class="number">10</span>;</span><br><span class="line">p=&amp;y <span class="comment">//legal</span></span><br><span class="line">*p=<span class="number">20</span> <span class="comment">//illegal</span></span><br><span class="line">y=<span class="number">20</span> <span class="comment">//legal because y is not const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;y; <span class="comment">//illegal because we have declare y is const-&gt; y cannot be modified, if we use int *p-&gt; we can use the *p to change y&#x27;s value, we violate that &quot;y cannot be modified&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;y; <span class="comment">//legal</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-常指针"><a href="#2-4-2-常指针" class="headerlink" title="2.4.2 常指针"></a>2.4.2 常指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;x;</span><br></pre></td></tr></table></figure>
<p>p指向一个int类型的变量，可以通过*p改变该变量的值。但是不能改变p所指的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*p=<span class="number">10</span>  <span class="comment">//legal</span></span><br><span class="line"><span class="keyword">int</span> y=<span class="number">3</span>;</span><br><span class="line">p=&amp;y    <span class="comment">//illegal</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-指向常量的常指针"><a href="#2-4-3-指向常量的常指针" class="headerlink" title="2.4.3  指向常量的常指针"></a>2.4.3  指向常量的常指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;x</span><br></pre></td></tr></table></figure>
<p>既不能更改p所指的对象，也不能通过*p改变变量x的值<br>如果是二维指针：<br><img src="/2022/01/05/C-Plus-Plus-Interview-Note/cons_pointer.png" alt="img"></p>
<blockquote>
<p>conclude:  const影响的是离它最近的量  </p>
<ol>
<li>若const前面没有*(int * const p=&amp;x),则const影响的是该指针变量, 该变量的值不能改变，即不能指向其他的变量（ex:int * const p=&amp;x,p只能指向x)  </li>
<li>若const前有一个*(const int * p)， 则const影响的是*p, 即该指针可以指向其他的变量，但不能通过 *p改变其所指的当前变量的值</li>
</ol>
</blockquote>
<h2 id="2-5-类中使用const"><a href="#2-5-类中使用const" class="headerlink" title="2.5 类中使用const"></a>2.5 类中使用const</h2><p><a href="https://blog.csdn.net/nawuyao/article/details/52748747">https://blog.csdn.net/nawuyao/article/details/52748747</a></p>
<p>const、define的联系与区别</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C plus plus note</title>
    <url>/2022/01/03/C-plus-plus/</url>
    <content><![CDATA[<h1 id="C-basic"><a href="#C-basic" class="headerlink" title="C++ basic"></a>C++ basic</h1><font face=Times New Roman size=4.8>
OP三大原则
封装（encapsulation): bundle data and methods dealing with these data together in an object. Hide the details of the data and the action. Restrict only access to the publicized methods.
数据在里面，操作在外面

<p>继承，多态性</p>
<p>同一个对象之间可以互相访问私有的成员变量类的成员变量在类的所有函数中都能使用成员变量不在类里面，而是在每一个类的对象中 (成员变量-&gt;7:28)<br>声明只是告诉别人有一个这个东西，而不知道在哪里函数是属于类的，不是属于对象的private是对类来说的，而不是对象</p>
<p>C++的OOP特性只在源代码级别存在， 编译之后就不是OOP的东西了。 编译成.o(二进制可执行程序后，丧失了C++所有的特性）</p>
<p>friends:申明别人（别的类，别的函数，别的类里面的某个函数）是你的盆友——&gt;她可以访问你的private的东西（访问限制那一节）</p>
<p>default argument只能在.h文件里操作，不能在.cpp文件里操作<br>default argument 是编译时的事， 不是运行时的事<br>本地变量与成员变量（field)</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。<br>只要创建对象，构造函数就会被调用<br>最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。对于示例2的代码，在栈上创建对象可以写作Student stu()或Student stu，在堆上创建对象可以写作Student *pstu = new Student()或Student *pstu = new Student，它们都会调用构造函数 Student()。<br>构造函数使用初始化列表：成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关<br>初始化 const 成员变量的唯一方法就是使用初始化列表</p>
<p>析构函数没有返回类型，不能有参数<br>被析构之前（对象被消灭的时候），析构函数会被调用<br>当一个对象离开scope时，析构函数会被调用。析构意味着该对象拥有的空间要被收回<br>The only evidence for a destructor call is the closing brace of the scope that surrounds the object</p>
<p>this是一个指针，类型是这个函数所属的那个类的对象的指针<br>在成员函数中用到成员变量时，实际上所有的成员变量都可以看做前面有this-&gt;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">int</span> initiallen);</span><br><span class="line">    ~Line;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">int</span> initiallen)&#123;</span><br><span class="line">    len=initiallen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~<span class="built_in">Line</span>()&#123;</span><br><span class="line">    cout&lt;&lt; Line::~Line&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;<span class="comment">// 此时10.0会传给len</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>The complier allocates all the storage for a scope at the opening brace of that scope</p>
<p>The constructor call does not happen until the sequence point where the object is defined</p>
<p>一个对象没有做过构造，不能被析构</p>
<p>A default constructor is one that can be called with no arguments</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>&#123;</span></span><br><span class="line">             <span class="keyword">float</span> f;</span><br><span class="line">             <span class="keyword">int</span> i;</span><br><span class="line">             <span class="built_in">Y</span>(<span class="keyword">int</span> a);  <span class="comment">//constructor</span></span><br><span class="line">&#125;</span><br><span class="line">Y y1[]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>), <span class="built_in">Y</span>(<span class="number">2</span>), <span class="built_in">Y</span>(<span class="number">3</span>)&#125;;</span><br><span class="line">Y y1[<span class="number">2</span>]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>)&#125;   <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>

<h2 id="New-and-Delete"><a href="#New-and-Delete" class="headerlink" title="New and Delete"></a>New and Delete</h2><p>Dynamic memory allocation<br>new<br>new int;<br>new Stash;<br>1、如果Stash是一个类，会分配Stash对象的空间<br>2、分配完空间，会调用其构造函数：构造函数一定会被调用，当这个对象被创建的时候。 无论这个变量是本地变量还是堆里面的变量<br>3、该运算符的结果是地址<br>new int[10];  //分配10个int的空间</p>
<p>delete<br>delete p;<br>delete [] p;</p>
<p>如果new的时候带有[],则delete的时候也需要 []. 使用delete p所指对象时， 析构函数先被调用， 空间再被收回</p>
<p>new is the way to allocate memory as a program runs. Pointers become the only access to that memory</p>
<p>delete enables you to return memory to the memory poll when you are finished with it</p>
<h3 id="Dynamic-Arrays"><a href="#Dynamic-Arrays" class="headerlink" title="Dynamic Arrays"></a>Dynamic Arrays</h3><p>int * psome=new int [10]<br>the new operator returns the address of the first element of the blcok</p>
<p>delete []psome<br>The presence of the brackets tells the program that it should free the whole array, not just the element;<br>不带[], 空间会被回收，但是析构只有第一个会被调用一次。 没有[]，代表psome所指的地方只有一个对象，所以只需要调用它所指的地址上的对象的析构就可</p>
<p>Student *q=new<br>Student();<br>delete q;<br>1、调用Student(因为知道q的类型，所以知道需要调用Student的析构，而不是其他的析构）的析构<br>2、回收空间</p>
<p>Student *r=new;<br>Student[10];<br>delete r;   //它认为r所指的是一个，会调用r所指的那个对象的析构， 只析构一个，后面9个没管<br>delete []r;</p>
<p>int *a=new int[10]<br>a++<br>delete []a  //运行错误， 找不到</p>
<p>It’s safe to apply delete to the null pointer</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;p=<span class="keyword">new</span> <span class="keyword">int</span>;i=<span class="number">0</span>; cout&lt;&lt;<span class="string">&quot;A::A()&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;<span class="keyword">if</span>(p) <span class="keyword">delete</span> p; cout&lt;&lt;<span class="string">&quot;A::~A()&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//if(p)最好加，也可以不加</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>-&gt;i=i;&#125;  </span><br><span class="line">    <span class="comment">// i=i不对，就近原则，这里的i把成员变量中的i覆盖了  注意这里this的用法， this-&gt;i指的是调用的那个函数的对象的i </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hello&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;p=<span class="keyword">new</span> <span class="keyword">int</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Access-limitation"><a href="#Access-limitation" class="headerlink" title="Access limitation"></a>Access limitation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//int *p;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;i=<span class="number">0</span>; cout&lt;&lt;<span class="string">&quot;A::A()&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>-&gt;i=i;&#125;  <span class="comment">// i=i不对，就近原则，这里的i把成员变量中的i覆盖了  注意这里this的用法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hello&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A *q)</span></span>&#123;cout&lt;&lt;q-&gt;i&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p=<span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">    A b;</span><br><span class="line">    b.<span class="built_in">set</span>(<span class="number">100</span>);</span><br><span class="line">    p[<span class="number">0</span>].<span class="built_in">g</span>(&amp;b);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个类的对象之间可以互相访问私有的成员变量</p>
<h2 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h2><p>Can declare a global function as a friend, as well as a member function of another class, or even an entire class, as a friend</p>
<p>class defaults to private<br>struct defaults to public<br>the only difference between class and struct</p>
<p>if the class is too easy, we can use struct, but seldom use it </p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">p</span>(<span class="number">0</span>)&#123;&#125;  <span class="comment">//intialise list:在构造函数的（）后加冒号， 冒号里写成员变量的名字，（）给出初始值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> xa=<span class="number">0.0</span>, <span class="keyword">float</span> ya=<span class="number">0.0</span>):<span class="built_in">y</span>(ya),<span class="built_in">x</span>(xa)&#123;&#125;</span><br><span class="line">    <span class="comment">//这两个变量的初始化早于构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyClass</span> &#123;</span></span><br><span class="line">    <span class="built_in">CMyClass</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyClass::<span class="built_in">CMyClass</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">m_y</span>(y), <span class="built_in">m_x</span>(m_y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可能以为上面的代码将会首先做 m_y=y，然后做 m_x=m_y，最后它们有相同的值。但是编译器先初始化 m_x，然后是 m_y,，因为它们是按这样的顺序声明的。结果是 m_x 将有一个不可预测的值。有两种方法避免它，一个是总是按照你希望它们被初始化的顺序声明成员，第二个是，如果你决定使用初始化列表，总是按照它们声明的顺序罗列这些成员。这将有助于消除混淆。</p>
<p>order of initialization is order of declaration<br>-Not the order in the list<br>-Destoryed in the reverse order</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>类型名 &amp; 引用名 = 某变量名, 并将其初始化为引用某个变量<br>int n=4;<br>int &amp; r=n  // r引用了n, r的类型是int &amp;<br>某个变量的引用等价于这个变量，相当于这个变量的别名</p>
<p>定义引用时一定要将其初始化为某个变量<br>引用初始化后，一直引用该变量，不会再引用其他变量<br>引用只能引用变量， 不能引用常量和表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a=<span class="number">4</span>, b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> &amp;r1=a;</span><br><span class="line"><span class="keyword">double</span> &amp;r2=r1; <span class="comment">//r2也引用了a</span></span><br><span class="line">r2=<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; a&lt;&lt;endl; <span class="comment">//输出10</span></span><br><span class="line">r1=b; <span class="comment">//用b对r1进行赋值</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">//a=b</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n1,n2;</span><br><span class="line"><span class="built_in">swap</span>(n1,n2);  <span class="comment">// swap n1 and n2</span></span><br></pre></td></tr></table></figure>

<p>引用作为函数的返回值<br><font color=red>注意：不要返回局部变量的引用<br>用法：函数调用作为左值</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">10</span>;  <span class="comment">//静态变量存在全局区，数据在程序结束后释放</span></span><br><span class="line">    <span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;ref=<span class="built_in">test</span>() <span class="comment">//相当于int &amp;ref=a;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref= &quot;</span>&lt;&lt; ref &lt;&lt; endl;<span class="comment">//结果正确，因为编译器做了保留</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref= &quot;</span>&lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第二次结果错误，因为a的内存已经释放</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref2=<span class="built_in">test2</span>();</span><br><span class="line">    <span class="built_in">test2</span>()=<span class="number">1000</span>;  <span class="comment">//相当于做了a=1000的操作</span></span><br><span class="line">    cout&lt;&lt; ref2&lt;&lt; endl; <span class="comment">//result:1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">Setvalue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> n;&#125;  <span class="comment">//函数的返回值引用了n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Setvalue</span>()=<span class="number">40</span>;   <span class="comment">//等价于对n进行赋值</span></span><br><span class="line">    cout&lt;&lt; n;       <span class="comment">//n=40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义引用时，前面加const关键字，即为常引用<br>int n;<br>const int &amp;r=n;  r的类型为const int &amp;<br>r=200; //编译错，不能试图通过r修改n的值<br>n=300; 没问题<br>不能通过常引用修改其引用的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">(<span class="keyword">int</span> *x)</span></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//safe</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="comment">//return q; //error,因为q是本地变量，这个函数结束后就不存在了；</span></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//safe, x lives outside this scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(&amp;x);</span><br><span class="line">    <span class="built_in">g</span>(a);</span><br><span class="line">    <span class="built_in">h</span>()=<span class="number">16</span>;  <span class="comment">//一个函数的返回结果是一个reference,reference可以做左值。x=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h3><p><font color=red>引用的本质在C++内部实现是一个指针常量.指针常量指的是指针指向不能更改</font><br>可以转换为：int *const ref=&amp;a</p>
<h2 id="References-as-class-memebers"><a href="#References-as-class-memebers" class="headerlink" title="References as class memebers"></a>References as class memebers</h2><p>Declared without initial value<br>Must be initialized using constructor initializer list</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> &amp; m_y;</span><br><span class="line">        <span class="built_in">X</span>(<span class="keyword">int</span> &amp;a);</span><br><span class="line">&#125;</span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span> &amp;a):<span class="built_in">m_y</span>(a)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>作用：常量引用主要用来修饰形参，防止误操作<br>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_size=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> finalgrade[class_size]; <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = x;</span><br><span class="line"><span class="keyword">double</span> classAverage[size]; <span class="comment">//error 编译时不知道size的值 //运行时才知道，所以不知道要分配多少空间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cip;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">3</span>;</span><br><span class="line">ip=&amp;ci;</span><br><span class="line">cip=&amp;ci;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s2[]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s1在代码段中，s2在堆栈中<br>程序运行后，变量放在三种不同的地方。本地变量放在堆栈中，new出来的东西在heap中，全局变量在全局数据区中；全局变量中的常量：hello world等在代码段里面，代码段不可写</p>
<p>如果一个函数return 的是一个const，无所谓，因为常数本身不能做左值。如果return的是一个指针并且是const,那个这个指针不能做左值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> j = <span class="built_in">f3</span>();<span class="comment">//work fine</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">f4</span>(); <span class="comment">//but this works fine too</span></span><br><span class="line">    <span class="comment">//因为f4()是一个值，值可以赋给k, 并不是试图改变f4的返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当const在函数名前面的时候修饰的是函数返回值。</p>
<p>当const在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。 </p>
<p>const Currency the_raise(42, 38);<br>整个对象是一个const,对象中的值不能被修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="comment">//定义时也需要加上const</span></span><br><span class="line">    day++;<span class="comment">// Error modifies data member</span></span><br><span class="line">    <span class="built_in">set_day</span>(<span class="number">12</span>);   <span class="comment">//Error calls non_const memeber</span></span><br><span class="line">    <span class="keyword">return</span> day; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数名后面加const， 说明函数成员变量不能被修改<br>const 对象不能引用非const的成员函数<br>非const的对象可以引用const的成员函数<br>const的对象只能引用const的成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		_a = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a2</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a3</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//_a = 30;  //报错 const的函数不能对其数据成员进行修改操作。</span></span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">a1</span>();</span><br><span class="line">	a.<span class="built_in">a2</span>(); <span class="comment">//非const的对象可以引用const的成员函数</span></span><br><span class="line">	a.<span class="built_in">a3</span>();</span><br><span class="line">	<span class="keyword">const</span> A b;</span><br><span class="line">	b.<span class="built_in">a1</span>(); <span class="comment">//报错 const的对象，不能引用非const的成员函数</span></span><br><span class="line">	b.<span class="built_in">a2</span>();<span class="comment">//const的对象只能引用const的成员函数</span></span><br><span class="line">	b.<span class="built_in">a3</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//actually:void f(A* this)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f() const&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//it is void f(const A* this)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.<span class="built_in">f</span>();  <span class="comment">//result: printf f() const;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if the member is const, have to be initialized in initializer list of the constructor.<br>成员变量是const, 不能用该成员变量做数组的size. 在前面加上static就可以<br>enum{size=100};<br>int array[size];  /ok</p>
<p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
<p>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; &amp;<span class="title">same</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;s1, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(s2[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;<span class="keyword">int</span>&gt;::iterator it1=temp.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;<span class="keyword">int</span>&gt;::iterator it2;</span><br><span class="line">    <span class="keyword">for</span>(;it1&lt;temp.<span class="built_in">end</span>()<span class="number">-1</span>;it1++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(it2=it1+<span class="number">1</span>;it2&lt;temp.<span class="built_in">end</span>();it2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it1==*it2)&#123;</span><br><span class="line">                temp.<span class="built_in">erase</span>(it2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;temp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;temp=&quot;</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">98</span>,<span class="number">23</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;v3=<span class="built_in">same</span>(v1,v2);</span><br><span class="line">    temp.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v3.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v3=&quot;</span>&lt;&lt;v3[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v3.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;temp2=&quot;</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果函数的返回值是用引用并且前面有const, 只是代表其所赋的值，不能改变它。如上：不能通过v3改变temp，但temp本身可以改变。</p>
<h2 id="Inline-function"><a href="#Inline-function" class="headerlink" title="Inline function"></a>Inline function</h2><p>overhead for a function call<br>函数的参数和本地变量地位一样，都是在堆栈中<br>overhead for a function call<br>1、Push parameters<br>2、Push return address<br>3、Prepare return values<br>4、Pop all pushed</p>
<p>An inline function is expanded in place, like a preprocessor macro, so the overhead of the function call is eliminated.<br>将函数的代码嵌入到调它的地方去， 但依旧保持函数的独立性（有自己的空间，本地变量只在函数的scope中有效…)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> ++x&#125;;</span><br></pre></td></tr></table></figure>
<p>在.h和.cpp中都必须repeat<br>Repeat inline keyword at declaration and definition<br>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。<br>引入内联函数的目的是为了解决程序中函数调用的效率问题，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p>
<p>1.在内联函数内不允许使用循环语句和开关语句；<br>2.内联函数的定义必须出现在内联函数第一次调用之前；<br>3.类结构中所在的类说明内部定义的函数是内联函数。<br>使用：网易云（不是很懂）<br>在a.h中需要写<br>inline int plusOne(int x);<br>inline int plusOne(int x){return ++x};<br>在a.cpp中写入：<br>inline int plusOne(int x){return ++x};<br>在main.cpp中使用：f(10);<br>在一个函数前加上inline后，这个函数的定义不再是定义，而是申明，因此不需要a.cpp，只需要a.h</p>
<p>如果函数很小：2-3行，值得做成inline.如果函数在循环中被频繁调用，也值得做成inline</p>
<p>不inline:超过20行，递归</p>
<h2 id="Overloaded-Operator"><a href="#Overloaded-Operator" class="headerlink" title="Overloaded Operator"></a>Overloaded Operator</h2><p>operators must be overloaded on a class or enumeration type<br>重载的运算符必须保持原有的操作数的个数<br>优先级不能改变</p>
<p>Just a function with an operator name<br>-Use the operator keyboard as a prefi to name operator *(…)</p>
<p>can be member function<br>const String String::operator + (const String &amp;that)<br>String 这个类有个成员函数叫operator, 这时：已经有一个hidden parameter, this-&gt;, 因此参数表中出现一个that就可以了。 返回结果是const String</p>
<p>can be global function<br>const String::operator+(const String &amp;r, const String &amp; l)<br>参数表是两个参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Interger</span>(<span class="keyword">int</span> n=<span class="number">0</span>):<span class="built_in">i</span>(n)&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp;n)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Integer</span>(i+n.i);<span class="comment">//第三个const-&gt;this-&gt;i不能改变</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Integer x(1), y(5), z;<br>x+y=&gt;x.operator+(y)  operator+是一个函数名<br>运算符左边的算子叫receiver, 决定用哪个加。可能有integer的+， float的+….， 左边的receiver是一个integer的对象，于是用integer里面的成员加来做加</p>
<p>z=x+3 √<br>3不能直接用，实际上是用构造函数把3构造成一个integer的对象， 将这个对象给x的operator+做加法运算</p>
<p>z=3+y; ×   receiver决定了operator用哪个，除非y有一种方法把自己变成整数（后面会学）</p>
<p>For unary operators(unary-，(取负)，！etc)member functions require no arguments<br>const Integer operator-()const{<br>    return Integer(-i);<br>}<br>z=-x  // z.operator=(x.operator-());<br>用自己的值取负后制造出一个新的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp; lhs, <span class="keyword">const</span> Integer &amp; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp; lhs, <span class="keyword">const</span> Integer &amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Integer</span>(lhs.i+rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>z=3+y √<br>把3变成一个integer<br>z=3+7 √<br>3+7=10， 用构造函数将10构造出一个对象，给z<br>Members vs Free functions<br>unary operators should be members<br>=,(),[],-&gt;, -&gt;* must be members<br>assignment operators should be members<br>All other binary operators as non-members</p>
<h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h2><p>Suppose you need a list of X and a list of Y<br>The lists would use similar code<br>They differ by the type stored in the list</p>
<p>两种template:class, function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">swap function <span class="keyword">for</span> two <span class="keyword">int</span> arguments</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if we want to swap Person, float…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;x, T &amp;y)</span></span>&#123;</span><br><span class="line">    T temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The template keyword introduces the template<br>The class T specifies a parameterized type name<br><font color=red>Inside the tempate, use T as a type name</font><br>template 下面是什么，什么就是template. 该例子中，template下面是swap function, 所以swap是template<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">3</span>; <span class="keyword">int</span> j=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">swap</span>(i,j);    <span class="comment">//use explicit int swap</span></span><br><span class="line">folat k=<span class="number">4.5</span>; <span class="keyword">float</span> m=<span class="number">3.7</span></span><br><span class="line"><span class="built_in">swap</span>(k,m)    <span class="comment">//use instanstiate float swap</span></span><br><span class="line">std::string <span class="built_in">s</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="function">std::string <span class="title">t</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(s,t);</span><br></pre></td></tr></table></figure></p>
<p>Only exact match on types is used<br>模板中的参数是两个T，意味着完全相同的类型</p>
<p>Overloading rules<br>Check first for unique function match<br>Then check for unique function template match<br>Then do overloading on functions</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">(<span class="keyword">float</span> i, <span class="keyword">float</span> k)</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t, T u)</span></span>&#123;&#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2.0</span>);   <span class="comment">//error?</span></span><br></pre></td></tr></table></figure>
<p>The complier deduces the template type from the actual arguments passed into the function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">foo&lt;<span class="keyword">int</span>&gt;();  <span class="comment">//Type T is int</span></span><br><span class="line">foo&lt;<span class="keyword">float</span>&gt;();    <span class="comment">//Type T is float</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span>);</span><br><span class="line">    ~<span class="built_in">Vector</span>();</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&amp;);</span><br><span class="line">    Vector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&amp;);</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_elements;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vector<int> v1(100);  100是构造函数的参数<br>Vector<Complex> v2(256);<br>v1[20]=10;<br>v2[20]=v1[20];</p>
<h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p>1、普通函数调用可以发生隐式类型转换（如形参是int，实参是char, 将char转换为int传入）<br>2、函数模板，用自动类型转换，无法发生隐式类型转换<br>3、函数模板，用显示指定类型，可以发生隐式类型转换<br>建议使用显示类型的方式使用模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> m_age, string m_name):<span class="built_in">age</span>(m_age),<span class="built_in">name</span>(m_name)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getname</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用具体化Person的版本实现代码，具体优化调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.<span class="built_in">getage</span>()==p2.<span class="built_in">getage</span>() &amp;&amp; p1.<span class="built_in">getname</span>()==p2.<span class="built_in">getname</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> res=<span class="built_in">compare</span>(p1, p2);</span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1==p2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1!=p2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 利用具体化模板，可以解决自定义类型的通用化</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一个类的interface指的是对外公开的那些部分<br>当继承一个类时，需要对那个类进行扩充</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>():<span class="built_in">width</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">0</span>)&#123;cout&lt;&lt;<span class="string">&quot;Shape():&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> h):<span class="built_in">width</span>(w), <span class="built_in">height</span>(h)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::getheight</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    height=h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::getWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    width=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rec</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rec</span>():<span class="built_in">Shape</span>(<span class="number">3</span>,<span class="number">4</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Rec R;</span><br><span class="line">    R.<span class="built_in">getWidth</span>(<span class="number">4</span>);</span><br><span class="line">    R.<span class="built_in">getheight</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;R.<span class="built_in">Area</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exeception"><a href="#Exeception" class="headerlink" title="Exeception"></a>Exeception</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch1=s[<span class="number">100</span>];</span><br><span class="line">        cout&lt;&lt;ch1&lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(execption e)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[1]out of bound!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch2=s.<span class="built_in">at</span>(<span class="number">100</span>);</span><br><span class="line">        cout&lt;&lt;ch2&lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(execption &amp;e)&#123; <span class="comment">//exception类位于&lt;exception&gt;头文件中</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[2]out of bound!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 try 没有捕获到异常，输出了一个没有意义的字符（垃圾值）。因为[ ]不会检查下标越界，不会抛出异常，所以即使有错误，try 也检测不到。换句话说，发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到。所谓抛出异常，就是明确地告诉程序发生了什么错误。</p>
<p>第二个 try 检测到了异常，并交给 catch 处理，执行 catch 中的语句。需要说明的是，异常一旦抛出，会立刻被 try 检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是第 17 行的 at() 函数，它后面的 cout 语句就不会再被执行，所以看不到它的输出。</p>
<p>检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了；即使 catch 语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了</p>
<h3 id="发生异常的位置"><a href="#发生异常的位置" class="headerlink" title="发生异常的位置"></a>发生异常的位置</h3><p>异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被 try 检测到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Unknown Exception&quot;</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[1]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[2]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        cout&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result: Unknown Exception</span></span><br></pre></td></tr></table></figure>

<p>func() 在 try 块中被调用，它抛出的异常会被 try 检测到，进而被 catch 捕获。从运行结果可以看出，func() 中的 cout 和 try 中的 cout 都没有被执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Unknown Exception&quot;</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[1]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func_inner</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[2]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">func_outer</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[3]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        cout&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result: Unknown Exception</span></span><br></pre></td></tr></table></figure>

<p><font color=red>发生异常后，程序的执行流会沿着函数的调用链往前回退，直到遇见 try 才停止。在这个回退过程中，调用链中剩下的代码（所有函数中未被执行的代码）都会被跳过，没有执行的机会了。(不是很懂) </font></p>
<h3 id="C-异常类型以及多级catch匹配"><a href="#C-异常类型以及多级catch匹配" class="headerlink" title="C++异常类型以及多级catch匹配"></a>C++异常类型以及多级catch匹配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="built_in"><span class="keyword">catch</span></span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exceptionType是异常类型。异常类型可以是 int、char、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型<br>variable是变量，用来接受异常信息</p>
<p><a href="http://c.biancheng.net/view/2331.html">http://c.biancheng.net/view/2331.html</a></p>
<p>我们可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据）。</p>
<p>总起来说，catch 和真正的函数调用相比，多了一个「在运行阶段将实参和形参匹配」的过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Derived</span>();  <span class="comment">//抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: int&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">char</span> *)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: cahr *&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(Base)&#123;  <span class="comment">//匹配成功（向上转型）</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(Derived)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: Derived&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中，我们定义了一个基类 Base，又从 Base 派生类出了 Derived。抛出异常时，我们创建了一个 Derived 类的匿名对象，也就是说，异常的类型是 Derived。</p>
<p>我们期望的是，异常被catch(Derived)捕获，但是从输出结果可以看出，异常提前被catch(Base)捕获了，这说明 catch 在匹配异常类型时发生了向上转型（Upcasting）</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL的六大组件：容器，算法，迭代器，仿函数，适配器，空间配置器<br>1、容器：各种数据结构，如Lvector,list, deque, set, map等用来存储数据<br>2、算法：各种常用的算法，如：sort, find, copy, for_each等<br>3、迭代器：扮演了容器和算法之间的胶合剂<br>4、仿函数：行为类似函数，可作为算法的某种策略<br>5、适配器：一种用来修饰容器或者仿函数或迭代器接口的东西<br>6、空间配置器：负责空间的配置与管理</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string Name, <span class="keyword">int</span> Age):<span class="built_in">name</span>(Name), <span class="built_in">age</span>(Age)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Person::getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;name:&quot;&lt;&lt;(*it).name&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;age: &quot;&lt;&lt;(*it).age&lt;&lt;endl;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name: &quot;</span>&lt;&lt;it-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="string">&quot;age: &quot;</span>&lt;&lt;it-&gt;<span class="built_in">getAge</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 存放自定义数据类型的指针<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string Name, <span class="keyword">int</span> Age):<span class="built_in">name</span>(Name), <span class="built_in">age</span>(Age)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Person::getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Person *&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person *&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;name:&quot;&lt;&lt;(**it).getName()&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;age: &quot;&lt;&lt;(**it).getAge()&lt;&lt;endl;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name: &quot;</span>&lt;&lt;(*it)-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="string">&quot;age: &quot;</span>&lt;&lt;(*it)-&gt;<span class="built_in">getAge</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> vector与普通数组的区别：数组是静态空间，而vector可以动态扩展</p>
<p> 动态扩展并不是在原空间之后续接新的空间，而是找更大的内存空间，然后将元数据拷贝到新空间，释放原空间</p>
<h3 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h3><p>vector<T> v;  默认构造函数<br>vector(v.begin(), v.end()); 将v[begin(), end())区间内的元素拷贝给本身。注意前闭后开<br>vector(n, elem)   将n个elem拷贝给本身<br>vector(const vector &amp;vec)  拷贝构造函数</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Interview Note</title>
    <url>/2022/01/05/Network-Interview-Note/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome To My Website</title>
    <url>/2022/01/03/Welcome-To-My-Website-1/</url>
    <content><![CDATA[<font face=Times New Roman>
<font size=5>
This is my personal website and it is my first time to try to do it. Usually, I will share and write articals about SDE and other areas in computer science that I am interested. I am a green hand in CS area, if someone read my article and find mistakes, welcome to tell me and we can discuss it together.
]]></content>
      <tags>
        <tag>-Welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Note From Nesco Academy</title>
    <url>/2022/01/03/Network-note-from-nesco-academy/</url>
    <content><![CDATA[<p>基于Nesco Academy Network的学习笔记</p>
<font face="Times New Roman">
<font size=5>
<word space=1>

<h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><ul>
<li><p>Multiprogramming:</p>
<ul>
<li>Supported by most all current operating systems</li>
<li>More than one “unit of execution” at a time</li>
</ul>
</li>
<li><p>Uniprogramming</p>
<ul>
<li>Easier to design; no concurrency</li>
</ul>
</li>
</ul>
<h2 id="Introduction-to-concurrency"><a href="#Introduction-to-concurrency" class="headerlink" title="Introduction to concurrency"></a>Introduction to concurrency</h2><ul>
<li><p>Properties of concurrent computer systems</p>
<ul>
<li>Multiply threads</li>
<li>Shared resources(Memory-heaps, globals, devices)</li>
</ul>
</li>
<li><p>Benign Concurrency</p>
<ul>
<li>No shared data or communication</li>
<li>Read-only data(constant)</li>
</ul>
</li>
<li><p>What is shared?</p>
<ul>
<li>Local variables are not shared(never store a pointer to local variable in a global data structure)</li>
<li>Global variables are shared(stored in data segment, accessible to all threads)</li>
<li>Heap variables can be shared</li>
</ul>
</li>
<li><p>Risk Concurrency</p>
</li>
</ul>
<ol>
<li>Two threads access a shared resource without any synchronization</li>
<li>At least one modifies the resources<blockquote>
<p>This creates a race condition: when we have two threads that are accessing the same data without any kind of rules for access</p>
</blockquote>
</li>
</ol>
<h2 id="1-Process"><a href="#1-Process" class="headerlink" title="1 Process"></a>1 Process</h2><p>参考文章[<a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html]">https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html]</a></p>
<blockquote>
<p>A process is an abstraction of a running program. Process management is basically a way that the operating system manages the programs that we’ve opened.</p>
</blockquote>
<ul>
<li>Process stands for the single task, the CPU can handle one process while the other process will not be handled. Each process includes multiple threads.</li>
<li>Storage space: If the storage space is shared in the process, it means that each thread can use this space. But the size of each space is different, it means that when the thread use this space, other threads cannot use it until this thread finish its assingment.<ul>
<li>Mutual exclusion(Mutex): To avoid other threads use this space-&gt; use Mutex, once the thread notice this, they will wait int line. <font coloc=red>It can avoid multiple threads read and write the same storage.</font></li>
</ul>
</li>
<li>Some memory areas can only be used by a fixed number of threads. Once the number of the threads which want use the same memory areas is larger than this number, other threads will wait in line.<ul>
<li>Semaphore: 在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。<font color= red>用来保证多个线程不会互相冲突</font>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>inlcude:</p>
</blockquote>
<ol>
<li>以多进程形式，允许多个任务同时运行；</li>
<li>以多线程形式，允许单个任务分成不同的部分运行；</li>
<li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。<h3 id="1-1-Process-Execution"><a href="#1-1-Process-Execution" class="headerlink" title="1.1 Process Execution"></a>1.1 Process Execution</h3></li>
</ol>
<ul>
<li>OS creates a process <large> that contains code and data and manage the process until it terminates</li>
<li>Every Process contains certain information(PID, state, PC, stack pointer, CPU registers, memory management info)<h3 id="1-1-Process-State"><a href="#1-1-Process-State" class="headerlink" title="1.1 Process State"></a>1.1 Process State</h3></li>
</ul>
<ol>
<li>New: The process is being created</li>
<li>Ready: The process is waiting to be assigned to the processor</li>
<li>Running: Instrcutions are being executed</li>
<li>Waiting: The process is waiting for some event to occur(ex:I/O completion or reception of signal)</li>
<li>Terminatied: The process has finished the execution<br><img src="/2022/01/03/Network-note-from-nesco-academy/process.png" alt="img"></li>
</ol>
<h3 id="1-2-Process-Control-Block-PCB"><a href="#1-2-Process-Control-Block-PCB" class="headerlink" title="1.2 Process Control Block(PCB)"></a>1.2 Process Control Block(PCB)</h3><blockquote>
<p>When the operate system manage and control the process, it should know the position of the process.  In additon, it needs to know the ID, state, PC, priority, stack pointer etc of the process. So we use the PCB to store this information.</p>
</blockquote>
<h2 id="2-Thread"><a href="#2-Thread" class="headerlink" title="2 Thread"></a>2 Thread</h2><blockquote>
<p>A thread is the unit of execution within a process.</p>
</blockquote>
<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="1-Addressing-in-Networking"><a href="#1-Addressing-in-Networking" class="headerlink" title="1 Addressing in Networking"></a>1 Addressing in Networking</h2><p><img src="/2022/01/03/Network-note-from-nesco-academy/1.png" alt="image"> </p>
<h3 id="1-1-Port-number-and-IP-addressing"><a href="#1-1-Port-number-and-IP-addressing" class="headerlink" title="1.1 Port number and IP addressing"></a>1.1 Port number and IP addressing</h3><p>In transport layer, it will add the source port number and destination port number</p>
<font color=red>

<p>Transport Layer: port number<br>Network Layer: IP address<br>Data Link Layer: MAC address</font>  </p>
<p>Data Link Layer, the entire content will be converted to 0 and 1 and then provide this to the router</p>
<p>For the picture above, actuall, source port number and destination port number are 16-bits.<br>If it is IPV4 address, the IP address should be 32 bits and for IPV6 address, the IP address should be in 128 bits</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">! IP address can be IPV4 and IPV6</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-IP-addressing-and-MAC-addressing"><a href="#1-2-IP-addressing-and-MAC-addressing" class="headerlink" title="1.2 IP addressing and MAC addressing"></a>1.2 IP addressing and MAC addressing</h3><p><img src="/2022/01/03/Network-note-from-nesco-academy/2.png" alt="image"></p>
<p>In LAN1, for the sender, A is IP address and 10 is MAC address. For the router, F is the IP address and 20 is the MAC address. MAC address 是48位</p>
<p>在20，10中会发现，receiver的MAC is 95, but we do not use it, 我们将借助名称或IP地址与其他设备进行通信。 我们永远不会提供MAC address进行通信。 20代表的是router1的MAC address</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">! 视频9：00内容</span></span><br></pre></td></tr></table></figure>
<p>The exit point of router1, we can notice that the MAC address is changed.</p>
<p>Router1 collects all physical layer information and construct the data link layer part, after receiving the data link layer part it opens and sees what is the destination MAC address. And the MAC address is same with the router1 so it knows that this part of data is for it. And then it opens the network layer information and it finds different destination IP address, so the router concludes that this packet is not for this router.</p>
<p><font color=red>The router then delete the source and destination MAC address and put the new MAC address</p>
<p>如果接受者要回复发送者，则swap source MAC address and destination MAC address(ex:original-&gt; 95, 66, now-&gt; 66, 95) also, swap source IP address(A) and destination IP address(P)</font></p>
<p>像router这样的中间设备会检查physical layer information, data link layer information and network layer information</p>
<h2 id="2-The-TCP-IP-Protocol-Suite"><a href="#2-The-TCP-IP-Protocol-Suite" class="headerlink" title="2 The TCP/IP Protocol Suite"></a>2 The TCP/IP Protocol Suite</h2><p><img src="/2022/01/03/Network-note-from-nesco-academy/TCP_layer.png" alt="image"></p>
<p>In TCP layer:OSI-&gt; application layer, presentation layer and session layer-&gt;TCP application layer<br><strong>The TCP model is the actually implemented model, while the OSI model is just a guidline.</strong></p>
<p>Four layers in TCP</p>
<ul>
<li>Application: Represents data to the user, plus encoding and dialog control</li>
<li>Transport: Supports communication between diverse devices across diverse network</li>
<li>Internet: Determines the best path throuugh the network</li>
<li>Network Access: Controls the hardware and media that make up the network</li>
</ul>
<p><img src="/2022/01/03/Network-note-from-nesco-academy/TCP_model.png" alt="img"></p>
<p><font color=blue>PROTOCOL DATA UNIT(PDU)</font><br>Protocol data unit are named according to the protocol of the TCP/IP suite:data, segment, packet, frame, and bits.</p>
<p>The application layer information or application PDU is called data.</p>
<p>Once the transport layer information(port number) is added with the application data — segment.</p>
<p><strong>Application Layer PDU – Data</strong><br><strong>Transport Layer PDU – Segment</strong><br><strong>Network Layer PDU – Packet</strong><br><strong>Data Link Layer PDU – Frame</strong><br>(These frames are converted into 0 and 1 in physical layer)<br><strong>Physical Layer PDU – Bits</strong></p>
<h2 id="3-Basic-Networking-Command"><a href="#3-Basic-Networking-Command" class="headerlink" title="3 Basic Networking Command"></a>3 Basic Networking Command</h2><p>Every IP address is always accompanied by the Subnet Mask(子网掩码) and this Subnet Mask only determines who are the neighbors in our network</p>
<ul>
<li>in Mac: ifconfig</li>
<li>in Windows: ipconfig</li>
<li><strong>DNS(Domain Name Service:域名服务器)</strong><blockquote>
<p>无论何时给出什么名称，域名服务器都会相应所给名称的相应IP地址。 当有任何数据从我们的计算机出来时，DNS会将此名称解析为相应的IP地址</p>
</blockquote>
</li>
</ul>
<p><font color=red>command:nslookup – 查询DNS服务器以获得给定名称的IP地址</font><br>ex:peiruliu.cn –&gt; IP address由DNS解析<br>检查电脑能否访问该网站: ping website’s IP. if there is no loss, it is correct<br>Ping can check whether two computers are reachable<br><img src="/2022/01/03/Network-note-from-nesco-academy/IP.png" alt="img"></p>
<p>trace the route from my computer to the peiruliu.cn:tracerout<br><img src="/2022/01/03/Network-note-from-nesco-academy/trace.png" alt="img"></p>
<h2 id="4-Basic-of-Router"><a href="#4-Basic-of-Router" class="headerlink" title="4 Basic of Router"></a>4 Basic of Router</h2><p>In this session, we will be able to </p>
<ul>
<li>Know the basic of routers</li>
<li>Understand how to connect two different LAN using router therorectically</li>
<li>Understand the difference between switch and router</li>
</ul>
<h3 id="4-1-Switch"><a href="#4-1-Switch" class="headerlink" title="4.1  Switch"></a>4.1  Switch</h3><blockquote>
<p>A switch is a networking hardware that connects devices on computer network to establish a local area network(LAN)</p>
</blockquote>
<p><font color=red> In the conputer network, each device is identified with the help of Ip and MAC address.</font></p>
<p>The switch has the memory, so the switch can store the MAC address table in it memory</p>
<p><strong>What is MAC address table?</strong><br>In MAC address table, 会将设备的MAC address与连接到switch上的端口对应起来(video:23)</p>
<h3 id="4-2-Router"><a href="#4-2-Router" class="headerlink" title="4.2  Router"></a>4.2  Router</h3><blockquote>
<p>A router is a networking device that forwards data packet between computer newtorks<br>A router is connected to at least two networks, commonly two LANs or WANs or a LAN and its ISP’s network</p>
</blockquote>
<p>When we say computer networks, they are two different LAN.</p>
<p><strong>The differences between switch and router</strong></p>
<ul>
<li>The switch can connect two computers that belong to the same LAN, while the router can connect two computers that belong to the different LANs.</li>
<li>The router is a layer 3 device(network layer), while the switch is a 2 layer device(data linke layer)</li>
<li>Router stores routing table</li>
<li>Switch(Half/Full Duplex), Router(Full Duplex)</li>
</ul>
<h4 id="4-2-1-Working-of-Router"><a href="#4-2-1-Working-of-Router" class="headerlink" title="4.2.1 Working of Router"></a>4.2.1 Working of Router</h4><p><img src="/2022/01/03/Network-note-from-nesco-academy/router.png" alt="img"><br>The router has two interfaces, one interface connect one LAN, and another interface connect another LAN. </p>
<ol>
<li>The computer send data and 10.0.0.10 receive it.</li>
<li>The transfer the data to another interface(192.168.1.10)</li>
<li>Finally, the data will be received by the destination</li>
</ol>
<h2 id="5-Basics-of-Bridge"><a href="#5-Basics-of-Bridge" class="headerlink" title="5 Basics of Bridge"></a>5 Basics of Bridge</h2><ul>
<li>Understand the basics of bridge</li>
<li>Know the types of bridge</li>
<li>Understand the working of bridge</li>
<li>Understand the difference between router and bridge</li>
</ul>
<h3 id="5-1-Concept-of-the-Bridge"><a href="#5-1-Concept-of-the-Bridge" class="headerlink" title="5.1  Concept of the Bridge"></a>5.1  Concept of the Bridge</h3><ol>
<li>Bridge=Repeater+Functionality of reading MAC address</li>
<li>It is a layer 2 device</li>
<li>It is also used for interconnecting two LANs on the <font color=red>same protocol</font></li>
<li>It is also a two port device</li>
</ol>
<h3 id="5-2-Types-of-Bridges"><a href="#5-2-Types-of-Bridges" class="headerlink" title="5.2  Types of Bridges"></a>5.2  Types of Bridges</h3><ul>
<li>Transparent Bridges<blockquote>
<ul>
<li>These are the bridge in which the stations are completely unaware of the bridge’s existance</li>
<li>Reconfiguration of the station is unnecessary even if the bridge is added or removed from network(unlike the router: we used to give the IP address of the interface as the default gateway for all stations or PCs)</li>
</ul>
</blockquote>
</li>
<li>Sourece Routing Bridges<blockquote>
<ul>
<li>In these bridges, routing operation is performed by source station and the frame specified which route to follow  ??</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="5-3-Working-or-Bridges"><a href="#5-3-Working-or-Bridges" class="headerlink" title="5.3 Working or Bridges"></a>5.3 Working or Bridges</h2><p><img src="/2022/01/03/Network-note-from-nesco-academy/bridge.png" alt="img"></p>
<p><strong>The differences between the Bridge and Router</strong></p>
<table>
<thead>
<tr>
<th>Bridge</th>
<th><small>Router</th>
</tr>
</thead>
<tbody><tr>
<td><small>connect two LANs running in the same protocols</td>
<td><small>connect two LANs running on the different protocols</td>
</tr>
<tr>
<td><small>second layer device(process MAC address)</td>
<td><small>third layer device(process IP address)</td>
</tr>
</tbody></table>
<h2 id="6-Network-Devices"><a href="#6-Network-Devices" class="headerlink" title="6 Network Devices"></a>6 Network Devices</h2><ol>
<li><p>Repeater</p>
<blockquote>
<p>First layer device, operate in the Physical layer. It just regenerates the signal in a single LAN network</p>
</blockquote>
</li>
<li><p>Hub</p>
<blockquote>
<p>First layer device(LAN device). Shortcoming: It will broadcast whatever it receives</p>
</blockquote>
</li>
<li><p>Switch</p>
<blockquote>
<p>Second layer device(LAN devcie). Connecting two devices which belong to the same single LAN.<br>Unlike the Hub, it can send the data to the exact receiver</p>
</blockquote>
</li>
<li><p>Bridge</p>
<blockquote>
<p>Second layer device. It can also regenerates the signal</p>
</blockquote>
</li>
<li><p>Router</p>
<blockquote>
<p>Third layer device. Make decisions based on the IP address</p>
</blockquote>
</li>
<li><p>Multi-layer switch(Layer 3 swithc)</p>
<blockquote>
<p>can be the switch as well as the router</p>
</blockquote>
</li>
<li><p>Brouter</p>
<blockquote>
<p>Combination of router and bridge</p>
</blockquote>
</li>
<li><p>Modem</p>
</li>
<li><p>Firewall(Security Device)</p>
</li>
</ol>
<h1 id="7-Physical-layer"><a href="#7-Physical-layer" class="headerlink" title="7 Physical layer"></a>7 Physical layer</h1><ul>
<li>Understand the fundamental principles of physical layer</li>
<li>Know about the data and signals<br>(1) One of the major functions of the physical layer is to move data in the form of electronmagnetic signals across a transmission medium.<br>(2) The data usable to a person or an application are not in a form that can be transmitted over a network<br>(3) To be transmitted, data must be transformed to eletromagnetic signals.<br><img src="/2022/01/03/Network-note-from-nesco-academy/physical1.png" alt="img"><br>User generates the data–&gt; Application receives the data–&gt; dat7a have to be converted to signal(<strong>physical layer do tihs conversition</strong>)<br>In source and destination, they focus more on the data. And these data have to be converted to signals by the physical layer</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Django Note</title>
    <url>/2022/01/07/Django/</url>
    <content><![CDATA[<font size=4>
<font face=Times New Roman>

<p>本文是基于<a href="https://b23.tv/Tga4ZV8">django入门</a>和<a href="https://b23.tv/hWiSZ8V">适合零基础小白的Django教程</a>学习笔记</p>
<h1 id="Djngo"><a href="#Djngo" class="headerlink" title="Djngo"></a>Djngo</h1><h2 id="1-Web-前端开发介绍"><a href="#1-Web-前端开发介绍" class="headerlink" title="1 Web 前端开发介绍"></a>1 Web 前端开发介绍</h2><p>在web开发中所编写的服务器端的程序的目的是为了动态地生成网页（HTML组成），使用浏览器访问即可看到效果</p>
<ol>
<li><p>什么是客户端（浏览器端，前端），什么是移动端，什么是服务器端？<br>(1) 客户端：直接面向客户的一端叫做前端，基于web开发的叫做web前端（制作的网站:打开淘宝，京东等,使用手机访问）<br>(2) 手机，平板电脑等是移动端</p>
</li>
<li><p>什么是服务器，什么是云服务器</p>
</li>
<li><p>Web的工作原理<br><img src="/2022/01/07/Django/Web.png" alt="img"><br>(1) 打开电脑，输入网址–&gt;回车相当于向服务器发出请求。<br>(2) 通过域名或IP地址找到服务器，发出请求<br>(3) 服务器根据请求地址和请求方式找到对应的内容(ex:想访问某些商品信息，服务器在数据库中找到对应的商品信息–&gt;相应给客户端浏览器上)<br><img src="/2022/01/07/Django/web2.png" alt="img"><br>负载均衡负责分发，每次请求时，负责找到合适的服务器做相应</p>
</li>
<li><p>HTTP 协议</p>
</li>
</ol>
<h2 id="2-HTML基础语法"><a href="#2-HTML基础语法" class="headerlink" title="2 HTML基础语法"></a>2 HTML基础语法</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  </span><br><span class="line">             <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="comment">&lt;!--网页标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个网页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://peiruliu.cn/&quot;</span>&gt;</span>我的个人网站<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">             </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>有两部分</li>
</ul>
<ol>
<li>&lt; !DOCTYPES html &gt; : 类型</li>
<li>每个网页的开头都有<html>, 结尾是</html><br>(1) head:<br>(2) body:网页的内容呈现都在body里面</li>
</ol>
<ul>
<li>注释<br>&lt; !– 唯一的HTML注释 –&gt;</li>
</ul>
<h3 id="2-1-HTML常用标签"><a href="#2-1-HTML常用标签" class="headerlink" title="2.1 HTML常用标签"></a>2.1 HTML常用标签</h3><ul>
<li>格式化标签<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hn&gt;...&lt;hn&gt;  其中n为1-6的值。标题标签</span><br><span class="line">&lt;i&gt;斜体&lt;/i&gt;    </span><br><span class="line">&lt;em&gt;强调斜体&lt;/em&gt;</span><br><span class="line">&lt;b&gt;加粗&lt;/b&gt;</span><br><span class="line">&lt;strong&gt;强调加粗&lt;/strong&gt;</span><br><span class="line">&lt;cite&gt;作品的标题(引用)&lt;/cite&gt;</span><br><span class="line">&lt;sub&gt;下标&lt;/sub&gt;</span><br><span class="line">&lt;sup&gt;上标&lt;/sup&gt;</span><br><span class="line">&lt;del&gt;删除线&lt;/del&gt;</span><br><span class="line">&lt;u&gt;u下划线标签&lt;/u&gt;&lt;br/&gt;  &lt;!-- br是换行的意思--&gt;</span><br><span class="line">&lt;u&gt;u下划线标签&lt;/u&gt;&lt;br/&gt;&lt;br/&gt;</span><br><span class="line">&lt;p&gt;换段&lt;/p&gt;</span><br><span class="line">&lt;hr/&gt;水平分割线</span><br><span class="line">&lt;ul&gt;...&lt;/ul&gt; 无序列表</span><br><span class="line">&lt;ol&gt;...&lt;/ol&gt;有序列表， 其中type类型值：Aali1 start属性表示起始值</span><br><span class="line">&lt;li&gt;...&lt;li&gt; 列表项</span><br><span class="line">&lt;div&gt;...&lt;div&gt;常用于组合块级元素，以便通过CSS来对这些元素进行格式化. 非常常用，默认的div标签会自动换行</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:600px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  This is my first website</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Welcome to visit it</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">爱好：</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>reading the book<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>surfing the internet<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>climbing the mountain<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>singing a song<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>reading the book<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>surfing the internet<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>climbing the mountain<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>singing a song<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>图片标签 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img /&gt; 在网页中插入一张图片</span><br><span class="line">• 属性：</span><br><span class="line">• src： 图片名及url地址</span><br><span class="line">• alt: 图片加载失败时的提示信息</span><br><span class="line">• title：文字提示属性</span><br><span class="line">• width：图片宽度</span><br><span class="line">• height：图片高度</span><br><span class="line">• border：边框线粗细</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;app.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;app&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span>&gt;</span>  <span class="comment">&lt;!--- 指定width, height会等比缩放 ---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png&quot;</span> <span class="attr">title</span>=<span class="string">&quot;google 图片&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>超链接标签</li>
</ul>
<h2 id="3-Django框架介绍与安装"><a href="#3-Django框架介绍与安装" class="headerlink" title="3 Django框架介绍与安装"></a>3 Django框架介绍与安装</h2><ul>
<li>如何找到 <a href="http://127.0.0.1:8000/myapp/">http://127.0.0.1:8000/myapp/</a> 该访问路径<br>一旦myweb(项目)下的urs文件被改变，默认的welcome页面就不会再显示</li>
<li>子路由和父路由</li>
</ul>
<h2 id="4-app创建与说明"><a href="#4-app创建与说明" class="headerlink" title="4 app创建与说明"></a>4 app创建与说明</h2><p><img src="/2022/01/07/Django/app.png" alt="img"></p>
<ul>
<li>确保APP已注册（在settings–&gt; INSTALL_APPS: ‘myapp.apps.MyappConfig’)</li>
<li>编写url和视图函数的对应关系(注意是myweb中的urls.py中)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># www.xxx.com/index/ -&gt; 函数（myapp的views里面）</span></span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">path(<span class="string">&#x27;index/&#x27;</span>, views.index) <span class="comment">#只要用户访问上面的url，就会在views.py文件中找index函数并执行该函数</span></span><br></pre></td></tr></table></figure></li>
<li>编写视图函数</li>
<li>启动jango项目</li>
</ul>
<h2 id="5-Django-的URL路由配置"><a href="#5-Django-的URL路由配置" class="headerlink" title="5 Django 的URL路由配置"></a>5 Django 的URL路由配置</h2><p>在urls.py文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&quot;find/&lt;int:sid&gt;&quot;</span>, views.find), <span class="comment">#在find/后加上任意整数进行访问， views中的find 函数需要有sid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在views中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">request, sid</span>):</span></span><br><span class="line">  <span class="keyword">return</span> HttpResponse(<span class="string">&quot;find....%d&quot;</span>%(sid))</span><br><span class="line"></span><br><span class="line">path(<span class="string">&quot;find/&lt;int:sid&gt;/&lt;str:name&gt;&quot;</span>, views.find2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在views中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find2</span>(<span class="params">request, sid, name</span>):</span></span><br><span class="line">  <span class="keyword">return</span> HttpResponse(<span class="string">&quot;find2....%d:%s&quot;</span>%(sid,name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">request, sid=<span class="number">0</span>, name=<span class="string">&quot;&quot;</span></span>):</span>  <span class="comment">#加入默认值， 不传参数也可以访问</span></span><br><span class="line">  <span class="keyword">return</span> HttpResponse(<span class="string">&quot;find2....%d:%s&quot;</span>%(sid,name))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过浏览器访问服务：<br>  127.0.0.1：8000/index–&gt; root url(根路由)–&gt;加载子路由（myweb/urls.py)–&gt;正则匹配访问路径（path)–&gt;视图函数（views.index)–&gt; views.py index()响应内容</p>
</blockquote>
<ul>
<li>什么是根路由，什么是子路由？<blockquote>
<pre><code>s
</code></pre>
</blockquote>
</li>
</ul>
<p>如果在每一个app中创建子路由，则：</p>
<ol>
<li>在myapp中创建urls.py文件<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views <span class="comment"># . represents the currecnt dir</span></span><br><span class="line">urlpatterns=[path(<span class="string">&quot;myapp/&quot;</span>, views.urls)]</span><br></pre></td></tr></table></figure></li>
<li>更改myweb中的urls.py文件<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line">ulspatterns =[</span><br><span class="line">  path(<span class="string">&quot;&quot;</span>, include(<span class="string">&#x27;myapp.urls&#x27;</span>)), <span class="comment">#在当前总路由文件路由中导入子路由文件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-1-跳转-重定向"><a href="#5-1-跳转-重定向" class="headerlink" title="5.1 跳转/重定向"></a>5.1 跳转/重定向</h3><ul>
<li>根据路由名称反向生成url请求地址</li>
</ul>
<ol>
<li>在urls.py中<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urlspatterns=[</span><br><span class="line">  path(<span class="string">&quot;&quot;</span>, views.index, name=<span class="string">&quot;index&quot;</span>),  <span class="comment">#该name可以帮助反向生成前面的url地址</span></span><br><span class="line">  path(<span class="string">&quot;add/&quot;</span>, views.add, name=<span class="string">&quot;add&quot;</span>),</span><br><span class="line">  path(<span class="string">&quot;find/&lt;int: sid&gt;/&lt;str: name&gt;/&quot;</span>, views.find),  </span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>在views.py中<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">  <span class="built_in">print</span>(reverse(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(reverse(<span class="string">&quot;find&quot;</span>, args=(<span class="number">100</span>,<span class="string">&#x27;elaine&#x27;</span>)))  </span><br><span class="line">  <span class="keyword">return</span> HttpReponse(<span class="string">&quot;Hello world&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>跳转/重定向<br>在views.py文件中<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">  <span class="keyword">return</span> redirect(reverse(<span class="string">&quot;find&quot;</span>, args=(<span class="number">100</span>,<span class="string">&#x27;elaine&#x27;</span>)))  <span class="comment"># 执行浏览器重定向（页面跳转）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-模板和静态文件"><a href="#6-模板和静态文件" class="headerlink" title="6 模板和静态文件"></a>6 模板和静态文件</h2><h3 id="6-1-模板"><a href="#6-1-模板" class="headerlink" title="6.1 模板"></a>6.1 模板</h3><p>在myapp中的views.py文件做如下修改:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">user_list</span>(<span class="params">request</span>):</span></span><br><span class="line">  <span class="comment"># 在app的目录下的templates寻找user_list.html(根据app的注册顺序，逐一去他们的templates目录中寻找)</span></span><br><span class="line">  <span class="keyword">return</span> render(request, <span class="string">&quot;user_list.html&quot;</span>)  <span class="comment">#在render内部会找到该文件并读取</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在对应的APP下面写templates,并在其中添加文件(add.html, user_list.html, etc).</p>
</blockquote>
<h3 id="6-2-静态文件"><a href="#6-2-静态文件" class="headerlink" title="6.2 静态文件"></a>6.2 静态文件</h3><p>在开发过程中，一般将：</p>
<ul>
<li>图片</li>
<li>CSS</li>
<li>js</li>
</ul>
<p>都当做静态文件处理。</p>
<blockquote>
<p>必须在当前的app(myapp)中新建static文件夹，并将图片放入其中.而在static文件夹下面，一般需要css, img, js, plugins</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--插入图片--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/static/img/1.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--jango推荐写法--&gt;</span></span><br><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;plugins/bootstrap-3.4.1/css/bootstrap.css&#x27; %&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;% static &#x27;img/1.png&#x27; %&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-Django的模型层"><a href="#7-Django的模型层" class="headerlink" title="7 Django的模型层"></a>7 Django的模型层</h2><ol>
<li>创建project<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin startproject mydemo</span><br></pre></td></tr></table></figure></li>
<li>进入创建的project的dir, 创建app<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py startapp myapp</span><br></pre></td></tr></table></figure></li>
<li>准备数据库（使用sudo -u postgres psql进入数据库）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建名为myapp的数据库</span><br><span class="line"> CREATE DATABASE mydb; </span><br><span class="line"> # 创建用户名和密码</span><br><span class="line"> CREATE USER myuser WITH ENCRYPTED PASSWORD &#x27;mypass&#x27;; </span><br><span class="line"> # 给创建的用户授权</span><br><span class="line"> GRANT ALL PRIVILEGES ON DATABASE mydb TO myuser;</span><br><span class="line"></span><br><span class="line"> # 以下设置可手动进行设置，也可以在postgresql.conf中进行配置</span><br><span class="line"> # 设置客户端字符为utf-8，防止乱码</span><br><span class="line"> ALTER ROLE myuser SET client_encoding TO &#x27;utf8&#x27;;</span><br><span class="line"> # 事务相关设置 - 推荐</span><br><span class="line"> ALTER ROLE myuser SET default_transaction_isolation TO &#x27;read committed&#x27;;</span><br><span class="line"> # 设置数据库时区为UTC - 推荐</span><br><span class="line"> ALTER ROLE myuser SET timezone TO &#x27;UTC&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>将创建的app名加入INSTALLED_APPS<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS=[<span class="string">&#x27;myapp&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li>数据库连接配置，修改配置文件settings.py<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line"> <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">     <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.postgresql_psycopg2&#x27;</span>,   <span class="comment"># 数据库引擎</span></span><br><span class="line">     <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;mysite&#x27;</span>,         <span class="comment"># 数据库名，Django不会帮你创建，需要自己进入数据库创建。</span></span><br><span class="line">     <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;elaine&#x27;</span>,     <span class="comment"># 设置的数据库用户名</span></span><br><span class="line">     <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;passcode&#x27;</span>,     <span class="comment"># 设置的密码</span></span><br><span class="line">     <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>,    <span class="comment"># 本地主机或数据库服务器的ip</span></span><br><span class="line">     <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;&#x27;</span>,         <span class="comment"># 数据库使用的端口</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>在models里面定义model类<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uers</span>(<span class="params">models.Model</span>):</span>  <span class="comment">#该user继承了django中的db里面的Models类</span></span><br><span class="line">   name=models.CharField(max_length=<span class="number">32</span>)  <span class="comment">#每一个属性代表一个字段，每一个字段代表定义的类型. char 代表字符串类型（告诉数据表，name是char类型）</span></span><br><span class="line">   age= models.IntegerField(default=<span class="number">22</span>) </span><br><span class="line">   phone=models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">   addtime=models.DateTimeField(default=datetime.now)</span><br></pre></td></tr></table></figure></li>
<li>执行以下两条指令， 若均不报错，则配置成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py makemigrations #若models没有更改则会显示no changes detected</span><br><span class="line">python3 manage.py migrate</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-1-模型实例"><a href="#7-1-模型实例" class="headerlink" title="7.1 模型实例"></a>7.1 模型实例</h3><ol>
<li>配置路由文件<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在urls文件中</span></span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> views</span><br><span class="line">urlpatterns=[</span><br><span class="line">  path(<span class="string">&quot;&quot;</span>, views.index,name=<span class="string">&quot;index&quot;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>在views文件中写入相应函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在views文件中</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> Users</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">  <span class="comment"># 执行model操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 添加操作</span></span><br><span class="line">  ob = Users() <span class="comment"># User实例化新的对象(空对象)</span></span><br><span class="line">  ob.name = <span class="string">&quot;Elaine&quot;</span></span><br><span class="line">  ob.age=<span class="number">20</span></span><br><span class="line">  ob.phone=<span class="string">&quot;576&quot;</span></span><br><span class="line">  ob.save()  <span class="comment">#新对象就是添加数据，已存在对象就是修改</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 删除操作</span></span><br><span class="line">  mod = Users.objects <span class="comment">#获取User的model对象</span></span><br><span class="line">  user = mod.get(<span class="built_in">id</span>=<span class="number">1</span>) <span class="comment">#获取ID值为1的数据信息</span></span><br><span class="line">  user.delete()  <span class="comment">#执行删除操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#修改操作</span></span><br><span class="line">  ob = Users.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print</span>(ob.name)  <span class="comment">#输出到终端</span></span><br><span class="line">  ob.name = <span class="string">&quot;lpr&quot;</span></span><br><span class="line">  ob.age = <span class="number">22</span></span><br><span class="line">  ob.save()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> HttpResponse(<span class="string">&quot;首页&quot;</span>)  <span class="comment">#显示在网页中</span></span><br></pre></td></tr></table></figure>
<font color=red>如果写入ob.save()则会报500错误？？</font></li>
</ol>
<blockquote>
<p>数据库配置不当导致。（原因？）<br>解决方法：新建新的数据库：使用python3 manage.py makemigrations和python3 manage.py migrate</p>
</blockquote>
<h3 id="7-2-模型查询"><a href="#7-2-模型查询" class="headerlink" title="7. 2 模型查询"></a>7. 2 模型查询</h3><ul>
<li>返回查询集的方法，称为过滤器<ul>
<li>all()</li>
<li>filter()</li>
<li>exclude()</li>
<li>order_by()</li>
<li>values():一个对象构成一个字典，然后构成一个列表返回</li>
</ul>
</li>
<li>写法<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">filter</span>(key1=value1, key2=value2) <span class="keyword">or</span></span><br><span class="line">  <span class="built_in">filter</span>(key1=value1)</span><br><span class="line">  <span class="built_in">filter</span>(key2=value2)</span><br><span class="line">``` python</span><br><span class="line">mod = Users.objects</span><br><span class="line">ulist = mod.<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> u <span class="keyword">in</span> ulist:</span><br><span class="line">  <span class="built_in">print</span>(u.<span class="built_in">id</span>, u.name, u.age)</span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">&quot;首页&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mod = Users.objects</span><br><span class="line">fil = mod.<span class="built_in">filter</span>(name=<span class="string">&#x27;lpr&#x27;</span>)</span><br><span class="line">fil1 = mod.<span class="built_in">filter</span>(age__gt=<span class="number">20</span>)  <span class="comment">#获取所有age大于20的信息</span></span><br><span class="line">fil2 = mod.<span class="built_in">filter</span>(age__gte=<span class="number">20</span>) <span class="comment">#获取所有age&gt;=20的信息</span></span><br><span class="line">fil3 = mod.order_by(<span class="string">&quot;age&quot;</span>)   <span class="comment">#age按照从小到大排序</span></span><br><span class="line">fil4 = mod.order_by(<span class="string">&quot;age&quot;</span>)[:<span class="number">3</span>]  <span class="comment">#只取前三个数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> u <span class="keyword">in</span> fil:</span><br><span class="line">  <span class="built_in">print</span>(u.<span class="built_in">id</span>, u.name, u.age)</span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">&quot;首页&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-Django视图层"><a href="#8-Django视图层" class="headerlink" title="8 Django视图层"></a>8 Django视图层</h2><p>一、 URLS: admin path(‘admin/‘, admin.site.urls),<br>问题：<br>加载不出静态文件<br>static文件夹位置和template文件夹位置，都应放在相应的app下面</p>
<h3 id="8-1-相应json数据格式"><a href="#8-1-相应json数据格式" class="headerlink" title="8.1 相应json数据格式"></a>8.1 相应json数据格式</h3><p>在views.py中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myview</span>(<span class="params">View</span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">		<span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello Views!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resp05</span>(<span class="params">request</span>):</span></span><br><span class="line">	data = [&#123;<span class="string">&#x27;id&#x27;</span>:<span class="number">1001</span>, <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;elaine&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;id&#x27;</span>:<span class="number">1002</span>, <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Mia&#x27;</span>, <span class="string">&#x27;age&#x27;</span>:<span class="number">22</span>&#125;,]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> JsonResponse(&#123;<span class="string">&quot;data&quot;</span>:data&#125;)</span><br></pre></td></tr></table></figure>
<p>路由配置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path(<span class="string">&#x27;resp04&#x27;</span>, Myview.as_view(), name = <span class="string">&#x27;resp04&#x27;</span>),</span><br></pre></td></tr></table></figure>
<p>在template 下的myapp中的index.html中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;resp05&#x27; %&#125;&quot;</span>&gt;</span>4. 相应json数据格式<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>效果： 在 <a href="http://127.0.0.1:8000/">http://127.0.0.1:8000/</a> 网址中访问该页面会出现超链接，链接点进去后显示data内容</p>
</blockquote>
<h3 id="8-2-Cookie-的使用"><a href="#8-2-Cookie-的使用" class="headerlink" title="8.2 Cookie 的使用"></a>8.2 Cookie 的使用</h3> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resp06</span>(<span class="params">request</span>):</span></span><br><span class="line"><span class="comment">#获取当前的相应对象</span></span><br><span class="line">response = HttpResponse(<span class="string">&#x27;cookie 的设置&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用相应对象进行cookie设置</span></span><br><span class="line">response.set_cookie(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">#返回相应对象</span></span><br><span class="line"><span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<ul>
<li>获取cookie<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(request.COOKIES.get(<span class="string">&#x27;a&#x27;</span>, <span class="literal">None</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 及爬虫笔记</title>
    <url>/2022/01/08/Python-Note/</url>
    <content><![CDATA[<p>本文是基于<a href="https://b23.tv/REpYmpP">黑马程序员Python教程</a>的学习笔记<br><font size=3><br><font face=Times New Roman></p>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="1-1-字符串切片"><a href="#1-1-字符串切片" class="headerlink" title="1.1 字符串切片"></a>1.1 字符串切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hello=<span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(hello[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(hello[-<span class="number">3</span>:-<span class="number">1</span>])  <span class="comment">#含头不含尾</span></span><br><span class="line"></span><br><span class="line">length=<span class="built_in">len</span>(hello)   <span class="comment">#获得hello字符串的长度</span></span><br></pre></td></tr></table></figure>

<h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2 函数"></a>2 函数</h2><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><blockquote>
<p>模拟浏览器，发送请求，获取响应<br>爬虫是模拟客户端(主要指浏览器)发送网络请求，接受请求响应，一种按照一定规则，自动地抓取互联网信息的程序</p>
</blockquote>
<ul>
<li>原则上，只要客户端能做的事，爬虫都能做</li>
<li>爬虫也只能获取客户端（浏览器）所展示出来的数据</li>
</ul>
<h2 id="1-爬虫流程"><a href="#1-爬虫流程" class="headerlink" title="1 爬虫流程"></a>1 爬虫流程</h2><ol>
<li>获取url</li>
<li>向url发送请求，并获取响应（需要http协议）</li>
<li>如果从响应中提取url,则继续发送请求获取响应</li>
<li>如果从响应中提取数据，则将数据进行保存</li>
</ol>
<h2 id="http-与-https的区别"><a href="#http-与-https的区别" class="headerlink" title="http 与 https的区别"></a>http 与 https的区别</h2><blockquote>
<p>https 比 http更安全，但是性能更低</p>
</blockquote>
<ul>
<li>HTTP: 超文本传输协议，默认端口号是80</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Python &amp; 爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Memory Management</title>
    <url>/2022/01/13/Memory-Management/</url>
    <content><![CDATA[<p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p>
<p>malloc分配的内存大小至少为size参数所指定的字节数<br>malloc的返回值是一个指针，指向一段可用内存的起始地址<br>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉<br>malloc应该尽快完成内存分配并返回（不能使用NP-hard的内存分配算法）<br>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</p>
<p>2.2.2 Heap内存模型<br>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p>
<p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：<br><img src="/2022/01/13/Memory-Management/heap.png" alt="img"></p>
<p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;  <span class="comment">//sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。如果将increment设置为0，则可以获得当前break的地址</span></span><br></pre></td></tr></table></figure>

<p>正式实现<br>一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;time.h&gt;<br>#include “my_malloc.h”</p>
<p>block head = NULL;<br>block free_head = NULL;<br>block tail = NULL;</p>
<p>void split_blk(block curr_blk,size_t size){<br>    block new_blk = NULL;<br>    new_blk = (void *)curr_blk + sizeof(struct m_block) + size;<br>    new_blk -&gt;prev = curr_blk -&gt; prev;<br>    new_blk -&gt;next = curr_blk -&gt; next;<br>    new_blk -&gt;size = curr_blk-&gt;size - sizeof(struct m_block)-size;<br>    if(curr_blk-&gt;next != NULL){<br>        curr_blk-&gt;next-&gt;prev = new_blk;<br>    }<br>    else{<br>        tail = new_blk;<br>    }<br>    if(curr_blk-&gt;prev !=NULL){<br>        curr_blk-&gt;prev-&gt;next = new_blk;<br>    }<br>    else{<br>        free_head = new_blk;<br>    }<br>    curr_blk-&gt;size = size;<br>}</p>
<p>void remove_front(block curr_blk,size_t size){<br>    if((int)curr_blk-&gt;size-(int)size-(int)sizeof(struct m_block)&gt;=0){<br>        split_blk(curr_blk, size);<br>    }<br>    else{<br>        free_head = curr_blk-&gt;next;<br>        if(curr_blk-&gt;next!=NULL){<br>            curr_blk-&gt;next-&gt;prev=NULL;<br>        }<br>        else{<br>            tail = NULL;<br>        }<br>    }<br>    curr_blk-&gt;next = NULL;<br>    curr_blk-&gt;prev = NULL;<br>}</p>
<p>void remove_last(block curr_blk, size_t size){<br>    if((int)curr_blk-&gt;size-(int)size-(int)sizeof(struct m_block)&gt;=0){<br>        split_blk(curr_blk, size);<br>    }<br>    else{<br>        tail = curr_blk-&gt;prev;<br>        if(curr_blk-&gt;prev!=NULL){<br>            curr_blk-&gt;prev-&gt;next=NULL;<br>        }<br>        else{<br>            free_head = NULL;<br>        }<br>    }<br>    curr_blk-&gt;next = NULL;<br>    curr_blk-&gt;prev = NULL;<br>}</p>
<p>void remove_blk(block curr_blk, size_t size){<br>    if((int)curr_blk-&gt;size-(int)size-(int)sizeof(struct m_block)&gt;=0){<br>        split_blk(curr_blk, size);<br>    }<br>    else{<br>        curr_blk-&gt;next-&gt;prev = curr_blk-&gt;prev;<br>        curr_blk-&gt;prev-&gt;next = curr_blk-&gt;next;<br>    }<br>    curr_blk-&gt;next = NULL;<br>    curr_blk-&gt;prev = NULL;<br>}</p>
<p>block ff_find(size_t len){<br>    // find the proper block from the start of free_list<br>    block curr_blk = free_head;<br>    while(curr_blk!=NULL){<br>        if(curr_blk-&gt;size&gt;=len){<br>            //remove the curr_blk from the free_list<br>            if(curr_blk-&gt;prev == NULL){<br>                remove_front(curr_blk, len);<br>            }<br>            else if(curr_blk-&gt;next == NULL){<br>                remove_last(curr_blk, len);<br>            }<br>            else{<br>                remove_blk(curr_blk, len);<br>            }<br>            break;<br>        }<br>        curr_blk=curr_blk-&gt;next;<br>    }<br>    return curr_blk;<br>}</p>
<p>block ff_extend(size_t len){<br>    block curr_meta = NULL;<br>    //allocate required memory<br>    curr_meta = sbrk(len + sizeof(struct m_block));<br>    //fail to allocate memory<br>    if(curr_meta == (void *)-1){<br>        return NULL;<br>    }<br>    else{<br>        curr_meta-&gt;prev = NULL;<br>        curr_meta-&gt;next = NULL;<br>        curr_meta-&gt;flag = 0;<br>        curr_meta-&gt;size = len;<br>    }<br>    return curr_meta;<br>}</p>
<p>void *ff_malloc(size_t size){<br>    if(size==0) return NULL;<br>    void * curr = NULL;<br>    void * last = NULL;<br>    void * extend_blk = NULL;<br>    void * first_blk = NULL;<br>    curr=sbrk(0);<br>    if(head==NULL){<br>        head=sbrk(0);<br>    }<br>    if(head!=curr){<br>        last = ff_find(size);<br>        if(last!=NULL){<br>            return last+sizeof(struct m_block);<br>        }<br>        else{<br>            extend_blk = ff_extend(size);<br>            return extend_blk+sizeof(struct m_block);<br>        }</p>
<pre><code>&#125;
else&#123;
    first_blk=ff_extend(size);
    return first_blk+sizeof(struct m_block);
&#125;
</code></pre>
<p>}</p>
<p>void prev_merge(block curr_blk){<br>    curr_blk-&gt;prev-&gt;size +=sizeof(struct m_block)+curr_blk-&gt;size;<br>    curr_blk-&gt;prev-&gt;next = curr_blk-&gt;next;<br>    if(curr_blk-&gt;next!=NULL){<br>        curr_blk-&gt;next-&gt;prev=curr_blk-&gt;prev;<br>    }<br>    else{<br>        tail = curr_blk-&gt;prev;<br>    }<br>    curr_blk-&gt;prev = NULL;<br>    curr_blk-&gt;next = NULL;<br>}</p>
<p>void next_merge(block curr_blk){<br>    curr_blk-&gt;size+=sizeof(struct m_block)+curr_blk-&gt;next-&gt;size;<br>    if(curr_blk-&gt;next-&gt;next!=NULL){<br>        block temp = curr_blk-&gt;next;<br>        curr_blk-&gt;next = curr_blk-&gt;next-&gt;next;<br>        curr_blk-&gt;next-&gt;prev = curr_blk;<br>        temp-&gt;next = NULL;<br>        temp-&gt;prev = NULL;<br>    }<br>    else{<br>        tail = curr_blk;<br>        curr_blk-&gt;next-&gt;prev = NULL;<br>        curr_blk-&gt;next = NULL;<br>    }<br>}</p>
<p>void add_blk(block curr_blk){<br>    block f_curr_blk = free_head;<br>    //if current free list is NULL<br>    if(free_head == NULL){<br>        free_head = (void *)curr_blk;<br>        tail = free_head;<br>        return;<br>    }<br>    // add the block in the front of the free list<br>    if((void *)free_head &gt; (void *)curr_blk){<br>        free_head-&gt;prev = curr_blk;<br>        curr_blk-&gt;next = free_head;<br>        // judge merge or not<br>        if((void *)curr_blk+sizeof(struct m_block)+curr_blk-&gt;size==(void *)free_head){<br>            next_merge(curr_blk);<br>        }<br>        free_head=curr_blk;<br>        return;<br>    }<br>    //add the block in the middle of the free list<br>    while(f_curr_blk-&gt;next!=NULL){<br>        if((void *)curr_blk&gt;=(void *)f_curr_blk+sizeof(struct m_block)+f_curr_blk-&gt;size &amp;&amp; (void *)curr_blk&lt;(void *)f_curr_blk-&gt;next){<br>            curr_blk-&gt;prev = f_curr_blk;<br>            curr_blk-&gt;next = f_curr_blk-&gt;next;<br>            f_curr_blk-&gt;next = curr_blk;<br>            curr_blk-&gt;next-&gt;prev = curr_blk;<br>            //judge prev_merge or not<br>            if((void *)curr_blk-&gt;prev+sizeof(struct m_block)+curr_blk-&gt;prev-&gt;size==(void *)curr_blk){<br>                prev_merge(curr_blk);<br>            }<br>            //judge next_merge of not<br>            if((void *)curr_blk+sizeof(struct m_block)+curr_blk-&gt;size==(void *)curr_blk-&gt;next){<br>                next_merge(curr_blk);<br>            }<br>            return;<br>        }<br>        f_curr_blk = f_curr_blk-&gt;next;<br>    }</p>
<pre><code>//add the block at the tail of the free list
if((void *)curr_blk &gt;= (void *)tail+sizeof(struct m_block)+tail-&gt;size)&#123;
tail-&gt;next =  curr_blk;
curr_blk-&gt;prev = tail;
    if((void *)tail+sizeof(struct m_block)+tail-&gt;size == (void *)curr_blk)&#123;
    //tail-&gt;size += sizeof(struct m_block)+curr_blk-&gt;size;
    prev_merge(curr_blk);

    &#125;
else&#123;
    //tail-&gt;next = curr_blk;
    //curr_blk-&gt;prev = tail;
    tail = curr_blk;
&#125;
    return;
&#125;
</code></pre>
<p>}</p>
<p>void ff_free(void *ptr){<br>    block curr_blk = NULL;<br>    curr_blk=ptr - sizeof(struct m_block);<br>    //call the add block function<br>    add_blk(curr_blk);<br>}</p>
<p>block bf_find(size_t len){<br>    block curr_blk = free_head;<br>    block rig_blk = NULL;<br>    size_t rest = 0;<br>    int flag = 0;<br>    if(curr_blk!=NULL){<br>        rest = curr_blk-&gt;size;<br>    }<br>    while(curr_blk!=NULL){<br>        if((curr_blk-&gt;size - len) &lt; rest &amp;&amp; curr_blk-&gt;size &gt;=len){<br>            rest = curr_blk-&gt;size-len;<br>            rig_blk = curr_blk;<br>        }<br>        curr_blk = curr_blk-&gt;next;<br>        if(rig_blk==NULL &amp;&amp; curr_blk!=NULL){<br>            rest = curr_blk-&gt;size;<br>        }<br>    }<br>    if(rig_blk != NULL){<br>        if(rig_blk-&gt;prev == NULL){<br>            remove_front(rig_blk, len);<br>        }<br>        else if(rig_blk-&gt;next == NULL){<br>            remove_last(rig_blk, len);<br>        }<br>        else{<br>            remove_blk(rig_blk, len);<br>        }<br>        return rig_blk;<br>    }<br>    else{<br>        return curr_blk;<br>    }<br>}</p>
<p>void *bf_malloc(size_t size){<br>    if(size==0) return NULL;<br>    void * curr = NULL;<br>    void * last = NULL;<br>    void * extend_blk = NULL;<br>    void * first_blk = NULL;<br>    curr=sbrk(0);<br>    if(head==NULL){<br>        head=sbrk(0);<br>    }<br>    if(head!=curr){<br>        last = bf_find(size);<br>        if(last!=NULL){<br>            return last+sizeof(struct m_block);<br>        }<br>        else{<br>            extend_blk = ff_extend(size);<br>            return extend_blk+sizeof(struct m_block);<br>        }</p>
<pre><code>&#125;
else&#123;
    first_blk=ff_extend(size);
    return first_blk+sizeof(struct m_block);
&#125;
</code></pre>
<p>}</p>
<p>void bf_free(void *ptr){<br>    return ff_free(ptr);<br>}</p>
<p>unsigned long get_data_segment_size() {<br>    unsigned long data_size = 0;<br>    data_size = sbrk(0) -(void *)head;<br>    return data_size;<br>}</p>
<p>unsigned long get_data_segment_free_space_size() {<br>    int i = 0;<br>    unsigned long result = 0;<br>    block curr_blk = free_head;<br>    while(curr_blk!=NULL){<br>        result += (curr_blk-&gt;size + sizeof(struct m_block));<br>        curr_blk = curr_blk-&gt;next;<br>        ++i;<br>    }<br>    //printf(“i=%d\n”, i);<br>    return result;</p>
<p>}</p>
]]></content>
  </entry>
</search>
