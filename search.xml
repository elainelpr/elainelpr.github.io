<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C plus plus note</title>
    <url>/2022/01/03/C-plus-plus/</url>
    <content><![CDATA[<h1 id="C-basic"><a href="#C-basic" class="headerlink" title="C++ basic"></a>C++ basic</h1><font face=Times New Roman size=4.8>
OP三大原则
封装（encapsulation): bundle data and methods dealing with these data together in an object. Hide the details of the data and the action. Restrict only access to the publicized methods.
数据在里面，操作在外面

<p>继承，多态性</p>
<p>同一个对象之间可以互相访问私有的成员变量类的成员变量在类的所有函数中都能使用成员变量不在类里面，而是在每一个类的对象中 (成员变量-&gt;7:28)<br>声明只是告诉别人有一个这个东西，而不知道在哪里函数是属于类的，不是属于对象的private是对类来说的，而不是对象</p>
<p>C++的OOP特性只在源代码级别存在， 编译之后就不是OOP的东西了。 编译成.o(二进制可执行程序后，丧失了C++所有的特性）</p>
<p>friends:申明别人（别的类，别的函数，别的类里面的某个函数）是你的盆友——&gt;她可以访问你的private的东西（访问限制那一节）</p>
<p>default argument只能在.h文件里操作，不能在.cpp文件里操作<br>default argument 是编译时的事， 不是运行时的事<br>本地变量与成员变量（field)</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。<br>只要创建对象，构造函数就会被调用<br>最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。对于示例2的代码，在栈上创建对象可以写作Student stu()或Student stu，在堆上创建对象可以写作Student *pstu = new Student()或Student *pstu = new Student，它们都会调用构造函数 Student()。<br>构造函数使用初始化列表：成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关<br>初始化 const 成员变量的唯一方法就是使用初始化列表</p>
<p>析构函数没有返回类型，不能有参数<br>被析构之前（对象被消灭的时候），析构函数会被调用<br>当一个对象离开scope时，析构函数会被调用。析构意味着该对象拥有的空间要被收回<br>The only evidence for a destructor call is the closing brace of the scope that surrounds the object</p>
<p>this是一个指针，类型是这个函数所属的那个类的对象的指针<br>在成员函数中用到成员变量时，实际上所有的成员变量都可以看做前面有this-&gt;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">int</span> initiallen);</span><br><span class="line">    ~Line;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">int</span> initiallen)&#123;</span><br><span class="line">    len=initiallen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~<span class="built_in">Line</span>()&#123;</span><br><span class="line">    cout&lt;&lt; Line::~Line&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;<span class="comment">// 此时10.0会传给len</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>The complier allocates all the storage for a scope at the opening brace of that scope</p>
<p>The constructor call does not happen until the sequence point where the object is defined</p>
<p>一个对象没有做过构造，不能被析构</p>
<p>A default constructor is one that can be called with no arguments</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>&#123;</span></span><br><span class="line">             <span class="keyword">float</span> f;</span><br><span class="line">             <span class="keyword">int</span> i;</span><br><span class="line">             <span class="built_in">Y</span>(<span class="keyword">int</span> a);  <span class="comment">//constructor</span></span><br><span class="line">&#125;</span><br><span class="line">Y y1[]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>), <span class="built_in">Y</span>(<span class="number">2</span>), <span class="built_in">Y</span>(<span class="number">3</span>)&#125;;</span><br><span class="line">Y y1[<span class="number">2</span>]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>)&#125;   <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>

<h2 id="New-and-Delete"><a href="#New-and-Delete" class="headerlink" title="New and Delete"></a>New and Delete</h2><p>Dynamic memory allocation<br>new<br>new int;<br>new Stash;<br>1、如果Stash是一个类，会分配Stash对象的空间<br>2、分配完空间，会调用其构造函数：构造函数一定会被调用，当这个对象被创建的时候。 无论这个变量是本地变量还是堆里面的变量<br>3、该运算符的结果是地址<br>new int[10];  //分配10个int的空间</p>
<p>delete<br>delete p;<br>delete [] p;</p>
<p>如果new的时候带有[],则delete的时候也需要 []. 使用delete p所指对象时， 析构函数先被调用， 空间再被收回</p>
<p>new is the way to allocate memory as a program runs. Pointers become the only access to that memory</p>
<p>delete enables you to return memory to the memory poll when you are finished with it</p>
<h3 id="Dynamic-Arrays"><a href="#Dynamic-Arrays" class="headerlink" title="Dynamic Arrays"></a>Dynamic Arrays</h3><p>int * psome=new int [10]<br>the new operator returns the address of the first element of the blcok</p>
<p>delete []psome<br>The presence of the brackets tells the program that it should free the whole array, not just the element;<br>不带[], 空间会被回收，但是析构只有第一个会被调用一次。 没有[]，代表psome所指的地方只有一个对象，所以只需要调用它所指的地址上的对象的析构就可</p>
<p>Student *q=new<br>Student();<br>delete q;<br>1、调用Student(因为知道q的类型，所以知道需要调用Student的析构，而不是其他的析构）的析构<br>2、回收空间</p>
<p>Student *r=new;<br>Student[10];<br>delete r;   //它认为r所指的是一个，会调用r所指的那个对象的析构， 只析构一个，后面9个没管<br>delete []r;</p>
<p>int *a=new int[10]<br>a++<br>delete []a  //运行错误， 找不到</p>
<p>It’s safe to apply delete to the null pointer</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;p=<span class="keyword">new</span> <span class="keyword">int</span>;i=<span class="number">0</span>; cout&lt;&lt;<span class="string">&quot;A::A()&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;<span class="keyword">if</span>(p) <span class="keyword">delete</span> p; cout&lt;&lt;<span class="string">&quot;A::~A()&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//if(p)最好加，也可以不加</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>-&gt;i=i;&#125;  </span><br><span class="line">    <span class="comment">// i=i不对，就近原则，这里的i把成员变量中的i覆盖了  注意这里this的用法， this-&gt;i指的是调用的那个函数的对象的i </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hello&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;p=<span class="keyword">new</span> <span class="keyword">int</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Access-limitation"><a href="#Access-limitation" class="headerlink" title="Access limitation"></a>Access limitation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//int *p;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;i=<span class="number">0</span>; cout&lt;&lt;<span class="string">&quot;A::A()&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>-&gt;i=i;&#125;  <span class="comment">// i=i不对，就近原则，这里的i把成员变量中的i覆盖了  注意这里this的用法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hello&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A *q)</span></span>&#123;cout&lt;&lt;q-&gt;i&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p=<span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">    A b;</span><br><span class="line">    b.<span class="built_in">set</span>(<span class="number">100</span>);</span><br><span class="line">    p[<span class="number">0</span>].<span class="built_in">g</span>(&amp;b);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个类的对象之间可以互相访问私有的成员变量</p>
<h2 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h2><p>Can declare a global function as a friend, as well as a member function of another class, or even an entire class, as a friend</p>
<p>class defaults to private<br>struct defaults to public<br>the only difference between class and struct</p>
<p>if the class is too easy, we can use struct, but seldom use it </p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">p</span>(<span class="number">0</span>)&#123;&#125;  <span class="comment">//intialise list:在构造函数的（）后加冒号， 冒号里写成员变量的名字，（）给出初始值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> xa=<span class="number">0.0</span>, <span class="keyword">float</span> ya=<span class="number">0.0</span>):<span class="built_in">y</span>(ya),<span class="built_in">x</span>(xa)&#123;&#125;</span><br><span class="line">    <span class="comment">//这两个变量的初始化早于构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyClass</span> &#123;</span></span><br><span class="line">    <span class="built_in">CMyClass</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyClass::<span class="built_in">CMyClass</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">m_y</span>(y), <span class="built_in">m_x</span>(m_y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可能以为上面的代码将会首先做 m_y=y，然后做 m_x=m_y，最后它们有相同的值。但是编译器先初始化 m_x，然后是 m_y,，因为它们是按这样的顺序声明的。结果是 m_x 将有一个不可预测的值。有两种方法避免它，一个是总是按照你希望它们被初始化的顺序声明成员，第二个是，如果你决定使用初始化列表，总是按照它们声明的顺序罗列这些成员。这将有助于消除混淆。</p>
<p>order of initialization is order of declaration<br>-Not the order in the list<br>-Destoryed in the reverse order</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>类型名 &amp; 引用名 = 某变量名, 并将其初始化为引用某个变量<br>int n=4;<br>int &amp; r=n  // r引用了n, r的类型是int &amp;<br>某个变量的引用等价于这个变量，相当于这个变量的别名</p>
<p>定义引用时一定要将其初始化为某个变量<br>引用初始化后，一直引用该变量，不会再引用其他变量<br>引用只能引用变量， 不能引用常量和表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a=<span class="number">4</span>, b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> &amp;r1=a;</span><br><span class="line"><span class="keyword">double</span> &amp;r2=r1; <span class="comment">//r2也引用了a</span></span><br><span class="line">r2=<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; a&lt;&lt;endl; <span class="comment">//输出10</span></span><br><span class="line">r1=b; <span class="comment">//用b对r1进行赋值</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">//a=b</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n1,n2;</span><br><span class="line"><span class="built_in">swap</span>(n1,n2);  <span class="comment">// swap n1 and n2</span></span><br></pre></td></tr></table></figure>

<p>引用作为函数的返回值<br><font color=red>注意：不要返回局部变量的引用<br>用法：函数调用作为左值</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">10</span>;  <span class="comment">//静态变量存在全局区，数据在程序结束后释放</span></span><br><span class="line">    <span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;ref=<span class="built_in">test</span>() <span class="comment">//相当于int &amp;ref=a;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref= &quot;</span>&lt;&lt; ref &lt;&lt; endl;<span class="comment">//结果正确，因为编译器做了保留</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref= &quot;</span>&lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第二次结果错误，因为a的内存已经释放</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref2=<span class="built_in">test2</span>();</span><br><span class="line">    <span class="built_in">test2</span>()=<span class="number">1000</span>;  <span class="comment">//相当于做了a=1000的操作</span></span><br><span class="line">    cout&lt;&lt; ref2&lt;&lt; endl; <span class="comment">//result:1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">Setvalue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> n;&#125;  <span class="comment">//函数的返回值引用了n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Setvalue</span>()=<span class="number">40</span>;   <span class="comment">//等价于对n进行赋值</span></span><br><span class="line">    cout&lt;&lt; n;       <span class="comment">//n=40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义引用时，前面加const关键字，即为常引用<br>int n;<br>const int &amp;r=n;  r的类型为const int &amp;<br>r=200; //编译错，不能试图通过r修改n的值<br>n=300; 没问题<br>不能通过常引用修改其引用的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">(<span class="keyword">int</span> *x)</span></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//safe</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="comment">//return q; //error,因为q是本地变量，这个函数结束后就不存在了；</span></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//safe, x lives outside this scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(&amp;x);</span><br><span class="line">    <span class="built_in">g</span>(a);</span><br><span class="line">    <span class="built_in">h</span>()=<span class="number">16</span>;  <span class="comment">//一个函数的返回结果是一个reference,reference可以做左值。x=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h3><p><font color=red>引用的本质在C++内部实现是一个指针常量.指针常量指的是指针指向不能更改</font><br>可以转换为：int *const ref=&amp;a</p>
<h2 id="References-as-class-memebers"><a href="#References-as-class-memebers" class="headerlink" title="References as class memebers"></a>References as class memebers</h2><p>Declared without initial value<br>Must be initialized using constructor initializer list</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> &amp; m_y;</span><br><span class="line">        <span class="built_in">X</span>(<span class="keyword">int</span> &amp;a);</span><br><span class="line">&#125;</span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span> &amp;a):<span class="built_in">m_y</span>(a)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>作用：常量引用主要用来修饰形参，防止误操作<br>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_size=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> finalgrade[class_size]; <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = x;</span><br><span class="line"><span class="keyword">double</span> classAverage[size]; <span class="comment">//error 编译时不知道size的值 //运行时才知道，所以不知道要分配多少空间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cip;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">3</span>;</span><br><span class="line">ip=&amp;ci;</span><br><span class="line">cip=&amp;ci;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s2[]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s1在代码段中，s2在堆栈中<br>程序运行后，变量放在三种不同的地方。本地变量放在堆栈中，new出来的东西在heap中，全局变量在全局数据区中；全局变量中的常量：hello world等在代码段里面，代码段不可写</p>
<p>如果一个函数return 的是一个const，无所谓，因为常数本身不能做左值。如果return的是一个指针并且是const,那个这个指针不能做左值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> j = <span class="built_in">f3</span>();<span class="comment">//work fine</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">f4</span>(); <span class="comment">//but this works fine too</span></span><br><span class="line">    <span class="comment">//因为f4()是一个值，值可以赋给k, 并不是试图改变f4的返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当const在函数名前面的时候修饰的是函数返回值。</p>
<p>当const在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。 </p>
<p>const Currency the_raise(42, 38);<br>整个对象是一个const,对象中的值不能被修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="comment">//定义时也需要加上const</span></span><br><span class="line">    day++;<span class="comment">// Error modifies data member</span></span><br><span class="line">    <span class="built_in">set_day</span>(<span class="number">12</span>);   <span class="comment">//Error calls non_const memeber</span></span><br><span class="line">    <span class="keyword">return</span> day; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数名后面加const， 说明函数成员变量不能被修改<br>const 对象不能引用非const的成员函数<br>非const的对象可以引用const的成员函数<br>const的对象只能引用const的成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		_a = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a2</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a3</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//_a = 30;  //报错 const的函数不能对其数据成员进行修改操作。</span></span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">a1</span>();</span><br><span class="line">	a.<span class="built_in">a2</span>(); <span class="comment">//非const的对象可以引用const的成员函数</span></span><br><span class="line">	a.<span class="built_in">a3</span>();</span><br><span class="line">	<span class="keyword">const</span> A b;</span><br><span class="line">	b.<span class="built_in">a1</span>(); <span class="comment">//报错 const的对象，不能引用非const的成员函数</span></span><br><span class="line">	b.<span class="built_in">a2</span>();<span class="comment">//const的对象只能引用const的成员函数</span></span><br><span class="line">	b.<span class="built_in">a3</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//actually:void f(A* this)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f() const&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//it is void f(const A* this)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.<span class="built_in">f</span>();  <span class="comment">//result: printf f() const;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if the member is const, have to be initialized in initializer list of the constructor.<br>成员变量是const, 不能用该成员变量做数组的size. 在前面加上static就可以<br>enum{size=100};<br>int array[size];  /ok</p>
<p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
<p>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; &amp;<span class="title">same</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;s1, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(s2[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;<span class="keyword">int</span>&gt;::iterator it1=temp.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;<span class="keyword">int</span>&gt;::iterator it2;</span><br><span class="line">    <span class="keyword">for</span>(;it1&lt;temp.<span class="built_in">end</span>()<span class="number">-1</span>;it1++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(it2=it1+<span class="number">1</span>;it2&lt;temp.<span class="built_in">end</span>();it2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it1==*it2)&#123;</span><br><span class="line">                temp.<span class="built_in">erase</span>(it2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;temp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;temp=&quot;</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">98</span>,<span class="number">23</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;v3=<span class="built_in">same</span>(v1,v2);</span><br><span class="line">    temp.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v3.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v3=&quot;</span>&lt;&lt;v3[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v3.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;temp2=&quot;</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果函数的返回值是用引用并且前面有const, 只是代表其所赋的值，不能改变它。如上：不能通过v3改变temp，但temp本身可以改变。</p>
<h2 id="Inline-function"><a href="#Inline-function" class="headerlink" title="Inline function"></a>Inline function</h2><p>overhead for a function call<br>函数的参数和本地变量地位一样，都是在堆栈中<br>overhead for a function call<br>1、Push parameters<br>2、Push return address<br>3、Prepare return values<br>4、Pop all pushed</p>
<p>An inline function is expanded in place, like a preprocessor macro, so the overhead of the function call is eliminated.<br>将函数的代码嵌入到调它的地方去， 但依旧保持函数的独立性（有自己的空间，本地变量只在函数的scope中有效…)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> ++x&#125;;</span><br></pre></td></tr></table></figure>
<p>在.h和.cpp中都必须repeat<br>Repeat inline keyword at declaration and definition<br>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。<br>引入内联函数的目的是为了解决程序中函数调用的效率问题，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p>
<p>1.在内联函数内不允许使用循环语句和开关语句；<br>2.内联函数的定义必须出现在内联函数第一次调用之前；<br>3.类结构中所在的类说明内部定义的函数是内联函数。<br>使用：网易云（不是很懂）<br>在a.h中需要写<br>inline int plusOne(int x);<br>inline int plusOne(int x){return ++x};<br>在a.cpp中写入：<br>inline int plusOne(int x){return ++x};<br>在main.cpp中使用：f(10);<br>在一个函数前加上inline后，这个函数的定义不再是定义，而是申明，因此不需要a.cpp，只需要a.h</p>
<p>如果函数很小：2-3行，值得做成inline.如果函数在循环中被频繁调用，也值得做成inline</p>
<p>不inline:超过20行，递归</p>
<h2 id="Overloaded-Operator"><a href="#Overloaded-Operator" class="headerlink" title="Overloaded Operator"></a>Overloaded Operator</h2><p>operators must be overloaded on a class or enumeration type<br>重载的运算符必须保持原有的操作数的个数<br>优先级不能改变</p>
<p>Just a function with an operator name<br>-Use the operator keyboard as a prefi to name operator *(…)</p>
<p>can be member function<br>const String String::operator + (const String &amp;that)<br>String 这个类有个成员函数叫operator, 这时：已经有一个hidden parameter, this-&gt;, 因此参数表中出现一个that就可以了。 返回结果是const String</p>
<p>can be global function<br>const String::operator+(const String &amp;r, const String &amp; l)<br>参数表是两个参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Interger</span>(<span class="keyword">int</span> n=<span class="number">0</span>):<span class="built_in">i</span>(n)&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp;n)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Integer</span>(i+n.i);<span class="comment">//第三个const-&gt;this-&gt;i不能改变</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Integer x(1), y(5), z;<br>x+y=&gt;x.operator+(y)  operator+是一个函数名<br>运算符左边的算子叫receiver, 决定用哪个加。可能有integer的+， float的+….， 左边的receiver是一个integer的对象，于是用integer里面的成员加来做加</p>
<p>z=x+3 √<br>3不能直接用，实际上是用构造函数把3构造成一个integer的对象， 将这个对象给x的operator+做加法运算</p>
<p>z=3+y; ×   receiver决定了operator用哪个，除非y有一种方法把自己变成整数（后面会学）</p>
<p>For unary operators(unary-，(取负)，！etc)member functions require no arguments<br>const Integer operator-()const{<br>    return Integer(-i);<br>}<br>z=-x  // z.operator=(x.operator-());<br>用自己的值取负后制造出一个新的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp; lhs, <span class="keyword">const</span> Integer &amp; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp; lhs, <span class="keyword">const</span> Integer &amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Integer</span>(lhs.i+rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>z=3+y √<br>把3变成一个integer<br>z=3+7 √<br>3+7=10， 用构造函数将10构造出一个对象，给z<br>Members vs Free functions<br>unary operators should be members<br>=,(),[],-&gt;, -&gt;* must be members<br>assignment operators should be members<br>All other binary operators as non-members</p>
<h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h2><p>Suppose you need a list of X and a list of Y<br>The lists would use similar code<br>They differ by the type stored in the list</p>
<p>两种template:class, function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">swap function <span class="keyword">for</span> two <span class="keyword">int</span> arguments</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if we want to swap Person, float…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;x, T &amp;y)</span></span>&#123;</span><br><span class="line">    T temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The template keyword introduces the template<br>The class T specifies a parameterized type name<br><font color=red>Inside the tempate, use T as a type name</font><br>template 下面是什么，什么就是template. 该例子中，template下面是swap function, 所以swap是template<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">3</span>; <span class="keyword">int</span> j=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">swap</span>(i,j);    <span class="comment">//use explicit int swap</span></span><br><span class="line">folat k=<span class="number">4.5</span>; <span class="keyword">float</span> m=<span class="number">3.7</span></span><br><span class="line"><span class="built_in">swap</span>(k,m)    <span class="comment">//use instanstiate float swap</span></span><br><span class="line">std::string <span class="built_in">s</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="function">std::string <span class="title">t</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(s,t);</span><br></pre></td></tr></table></figure></p>
<p>Only exact match on types is used<br>模板中的参数是两个T，意味着完全相同的类型</p>
<p>Overloading rules<br>Check first for unique function match<br>Then check for unique function template match<br>Then do overloading on functions</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">(<span class="keyword">float</span> i, <span class="keyword">float</span> k)</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t, T u)</span></span>&#123;&#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2.0</span>);   <span class="comment">//error?</span></span><br></pre></td></tr></table></figure>
<p>The complier deduces the template type from the actual arguments passed into the function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">foo&lt;<span class="keyword">int</span>&gt;();  <span class="comment">//Type T is int</span></span><br><span class="line">foo&lt;<span class="keyword">float</span>&gt;();    <span class="comment">//Type T is float</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span>);</span><br><span class="line">    ~<span class="built_in">Vector</span>();</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&amp;);</span><br><span class="line">    Vector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&amp;);</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_elements;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vector<int> v1(100);  100是构造函数的参数<br>Vector<Complex> v2(256);<br>v1[20]=10;<br>v2[20]=v1[20];</p>
<h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p>1、普通函数调用可以发生隐式类型转换（如形参是int，实参是char, 将char转换为int传入）<br>2、函数模板，用自动类型转换，无法发生隐式类型转换<br>3、函数模板，用显示指定类型，可以发生隐式类型转换<br>建议使用显示类型的方式使用模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> m_age, string m_name):<span class="built_in">age</span>(m_age),<span class="built_in">name</span>(m_name)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getname</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用具体化Person的版本实现代码，具体优化调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.<span class="built_in">getage</span>()==p2.<span class="built_in">getage</span>() &amp;&amp; p1.<span class="built_in">getname</span>()==p2.<span class="built_in">getname</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> res=<span class="built_in">compare</span>(p1, p2);</span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1==p2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1!=p2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 利用具体化模板，可以解决自定义类型的通用化</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一个类的interface指的是对外公开的那些部分<br>当继承一个类时，需要对那个类进行扩充</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>():<span class="built_in">width</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">0</span>)&#123;cout&lt;&lt;<span class="string">&quot;Shape():&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> h):<span class="built_in">width</span>(w), <span class="built_in">height</span>(h)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::getheight</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    height=h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::getWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    width=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rec</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rec</span>():<span class="built_in">Shape</span>(<span class="number">3</span>,<span class="number">4</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Rec R;</span><br><span class="line">    R.<span class="built_in">getWidth</span>(<span class="number">4</span>);</span><br><span class="line">    R.<span class="built_in">getheight</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;R.<span class="built_in">Area</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exeception"><a href="#Exeception" class="headerlink" title="Exeception"></a>Exeception</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch1=s[<span class="number">100</span>];</span><br><span class="line">        cout&lt;&lt;ch1&lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(execption e)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[1]out of bound!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch2=s.<span class="built_in">at</span>(<span class="number">100</span>);</span><br><span class="line">        cout&lt;&lt;ch2&lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(execption &amp;e)&#123; <span class="comment">//exception类位于&lt;exception&gt;头文件中</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[2]out of bound!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 try 没有捕获到异常，输出了一个没有意义的字符（垃圾值）。因为[ ]不会检查下标越界，不会抛出异常，所以即使有错误，try 也检测不到。换句话说，发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到。所谓抛出异常，就是明确地告诉程序发生了什么错误。</p>
<p>第二个 try 检测到了异常，并交给 catch 处理，执行 catch 中的语句。需要说明的是，异常一旦抛出，会立刻被 try 检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是第 17 行的 at() 函数，它后面的 cout 语句就不会再被执行，所以看不到它的输出。</p>
<p>检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了；即使 catch 语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了</p>
<h3 id="发生异常的位置"><a href="#发生异常的位置" class="headerlink" title="发生异常的位置"></a>发生异常的位置</h3><p>异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被 try 检测到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Unknown Exception&quot;</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[1]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[2]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        cout&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result: Unknown Exception</span></span><br></pre></td></tr></table></figure>

<p>func() 在 try 块中被调用，它抛出的异常会被 try 检测到，进而被 catch 捕获。从运行结果可以看出，func() 中的 cout 和 try 中的 cout 都没有被执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Unknown Exception&quot;</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[1]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func_inner</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[2]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">func_outer</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[3]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        cout&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result: Unknown Exception</span></span><br></pre></td></tr></table></figure>

<p><font color=red>发生异常后，程序的执行流会沿着函数的调用链往前回退，直到遇见 try 才停止。在这个回退过程中，调用链中剩下的代码（所有函数中未被执行的代码）都会被跳过，没有执行的机会了。(不是很懂) </font></p>
<h3 id="C-异常类型以及多级catch匹配"><a href="#C-异常类型以及多级catch匹配" class="headerlink" title="C++异常类型以及多级catch匹配"></a>C++异常类型以及多级catch匹配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="built_in"><span class="keyword">catch</span></span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exceptionType是异常类型。异常类型可以是 int、char、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型<br>variable是变量，用来接受异常信息</p>
<p><a href="http://c.biancheng.net/view/2331.html">http://c.biancheng.net/view/2331.html</a></p>
<p>我们可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据）。</p>
<p>总起来说，catch 和真正的函数调用相比，多了一个「在运行阶段将实参和形参匹配」的过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Derived</span>();  <span class="comment">//抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: int&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">char</span> *)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: cahr *&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(Base)&#123;  <span class="comment">//匹配成功（向上转型）</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(Derived)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: Derived&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中，我们定义了一个基类 Base，又从 Base 派生类出了 Derived。抛出异常时，我们创建了一个 Derived 类的匿名对象，也就是说，异常的类型是 Derived。</p>
<p>我们期望的是，异常被catch(Derived)捕获，但是从输出结果可以看出，异常提前被catch(Base)捕获了，这说明 catch 在匹配异常类型时发生了向上转型（Upcasting）</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL的六大组件：容器，算法，迭代器，仿函数，适配器，空间配置器<br>1、容器：各种数据结构，如Lvector,list, deque, set, map等用来存储数据<br>2、算法：各种常用的算法，如：sort, find, copy, for_each等<br>3、迭代器：扮演了容器和算法之间的胶合剂<br>4、仿函数：行为类似函数，可作为算法的某种策略<br>5、适配器：一种用来修饰容器或者仿函数或迭代器接口的东西<br>6、空间配置器：负责空间的配置与管理</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string Name, <span class="keyword">int</span> Age):<span class="built_in">name</span>(Name), <span class="built_in">age</span>(Age)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Person::getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;name:&quot;&lt;&lt;(*it).name&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;age: &quot;&lt;&lt;(*it).age&lt;&lt;endl;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name: &quot;</span>&lt;&lt;it-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="string">&quot;age: &quot;</span>&lt;&lt;it-&gt;<span class="built_in">getAge</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 存放自定义数据类型的指针<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string Name, <span class="keyword">int</span> Age):<span class="built_in">name</span>(Name), <span class="built_in">age</span>(Age)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Person::getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Person *&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person *&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;name:&quot;&lt;&lt;(**it).getName()&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;age: &quot;&lt;&lt;(**it).getAge()&lt;&lt;endl;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name: &quot;</span>&lt;&lt;(*it)-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="string">&quot;age: &quot;</span>&lt;&lt;(*it)-&gt;<span class="built_in">getAge</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> vector与普通数组的区别：数组是静态空间，而vector可以动态扩展</p>
<p> 动态扩展并不是在原空间之后续接新的空间，而是找更大的内存空间，然后将元数据拷贝到新空间，释放原空间</p>
<h3 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h3><p>vector<T> v;  默认构造函数<br>vector(v.begin(), v.end()); 将v[begin(), end())区间内的元素拷贝给本身。注意前闭后开<br>vector(n, elem)   将n个elem拷贝给本身<br>vector(const vector &amp;vec)  拷贝构造函数</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Database</title>
    <url>/2022/01/04/Database/</url>
    <content><![CDATA[<font size=4>


<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><strong>基于数据库系统概论的学习笔记</strong></p>
<h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><ul>
<li>数据库系统的发展<ul>
<li>层次/网状数据库系统</li>
<li>关系数据库系统</li>
<li>新一代数据库系统</li>
</ul>
</li>
<li>发展了一门计算机基础学科<ul>
<li>数据建模和DBMS核心技术为主</li>
</ul>
</li>
</ul>
<h2 id="2-数据库系统概述"><a href="#2-数据库系统概述" class="headerlink" title="2 数据库系统概述"></a>2 数据库系统概述</h2><p>4个基本概念</p>
<ul>
<li>数据（data)<blockquote>
<p>数据库中存储的基本对象，用来描述事物的符号记录(数字，文字，图形，音频，学生档案记录等)</p>
</blockquote>
</li>
<li>数据库（database, DB)<blockquote>
<p>长期存储在计算机内，有组织的，可共享的大量数据集合（存储数据的“仓库”）</p>
</blockquote>
</li>
<li>数据库管理系统(DataBase Management System, DBMS)<blockquote>
<p>MySQL属于其中的一种。数据库是通过DBMS创建和操作的容器</p>
</blockquote>
</li>
<li>数据库系统(DataBase System, DBS)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Welcome To My Website</title>
    <url>/2022/01/03/Welcome-To-My-Website-1/</url>
    <content><![CDATA[<p>This is my personal website and it is my first time to try to do it. Usually, I will share and write articals about SDE and other areas in computer science that I am interested. I am a green hand in CS area, if someone read my article and find mistakes, welcome to tell me and we can discuss it together.</p>
]]></content>
      <tags>
        <tag>-Welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Note From Nesco Academy</title>
    <url>/2022/01/03/Network-note-from-nesco-academy/</url>
    <content><![CDATA[<p>基于Nesco Academy Network的学习笔记</p>
<font face="Times New Roman">
<font size=5>
<word space=1>

<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="1-Addressing-in-Networking"><a href="#1-Addressing-in-Networking" class="headerlink" title="1 Addressing in Networking"></a>1 Addressing in Networking</h2><p><img src="/2022/01/03/Network-note-from-nesco-academy/1.png" alt="image"> </p>
<h3 id="1-1-Port-number-and-IP-addressing"><a href="#1-1-Port-number-and-IP-addressing" class="headerlink" title="1.1 Port number and IP addressing"></a>1.1 Port number and IP addressing</h3><p>In transport layer, it will add the source port number and destination port number</p>
<font color=red>

<p>Transport Layer: port number<br>Network Layer: IP address<br>Data Link Layer: MAC address</font>  </p>
<p>Data Link Layer, the entire content will be converted to 0 and 1 and then provide this to the router</p>
<p>For the picture above, actuall, source port number and destination port number are 16-bits.<br>If it is IPV4 address, the IP address should be 32 bits and for IPV6 address, the IP address should be in 128 bits</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">! IP address can be IPV4 and IPV6</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-IP-addressing-and-MAC-addressing"><a href="#1-2-IP-addressing-and-MAC-addressing" class="headerlink" title="1.2 IP addressing and MAC addressing"></a>1.2 IP addressing and MAC addressing</h3><p><img src="/2022/01/03/Network-note-from-nesco-academy/2.png" alt="image"></p>
<p>In LAN1, for the sender, A is IP address and 10 is MAC address. For the router, F is the IP address and 20 is the MAC address. MAC address 是48位</p>
<p>在20，10中会发现，receiver的MAC is 95, but we do not use it, 我们将借助名称或IP地址与其他设备进行通信。 我们永远不会提供MAC address进行通信。 20代表的是router1的MAC address</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">! 视频9：00内容</span></span><br></pre></td></tr></table></figure>
<p>The exit point of router1, we can notice that the MAC address is changed.</p>
<p>Router1 collects all physical layer information and construct the data link layer part, after receiving the data link layer part it opens and sees what is the destination MAC address. And the MAC address is same with the router1 so it knows that this part of data is for it. And then it opens the network layer information and it finds different destination IP address, so the router concludes that this packet is not for this router.</p>
<p><font color=red>The router then delete the source and destination MAC address and put the new MAC address</p>
<p>如果接受者要回复发送者，则swap source MAC address and destination MAC address(ex:original-&gt; 95, 66, now-&gt; 66, 95) also, swap source IP address(A) and destination IP address(P)</font></p>
<p>像router这样的中间设备会检查physical layer information, data link layer information and network layer information</p>
<h2 id="2-The-TCP-IP-Protocol-Suite"><a href="#2-The-TCP-IP-Protocol-Suite" class="headerlink" title="2 The TCP/IP Protocol Suite"></a>2 The TCP/IP Protocol Suite</h2><p><img src="/2022/01/03/Network-note-from-nesco-academy/TCP_layer.png" alt="image"></p>
<p>In TCP layer:OSI-&gt; application layer, presentation layer and session layer-&gt;TCP application layer<br><strong>The TCP model is the actually implemented model, while the OSI model is just a guidline.</strong></p>
<p>Four layers in TCP</p>
<ul>
<li>Application: Represents data to the user, plus encoding and dialog control</li>
<li>Transport: Supports communication between diverse devices across diverse network</li>
<li>Internet: Determines the best path throuugh the network</li>
<li>Network Access: Controls the hardware and media that make up the network</li>
</ul>
<p><img src="/2022/01/03/Network-note-from-nesco-academy/TCP_model.png" alt="img"></p>
<p><font color=blue>PROTOCOL DATA UNIT(PDU)</font><br>Protocol data unit are named according to the protocol of the TCP/IP suite:data, segment, packet, frame, and bits.</p>
<p>The application layer information or application PDU is called data.</p>
<p>Once the transport layer information(port number) is added with the application data — segment.</p>
<p><strong>Application Layer PDU – Data</strong><br><strong>Transport Layer PDU – Segment</strong><br><strong>Network Layer PDU – Packet</strong><br><strong>Data Link Layer PDU – Frame</strong><br>(These frames are converted into 0 and 1 in physical layer)<br><strong>Physical Layer PDU – Bits</strong></p>
<h2 id="3-Basic-Networking-Command"><a href="#3-Basic-Networking-Command" class="headerlink" title="3 Basic Networking Command"></a>3 Basic Networking Command</h2><p>Every IP address is always accompanied by the Subnet Mask(子网掩码) and this Subnet Mask only determines who are the neighbors in our network</p>
<ul>
<li>in Mac: ifconfig</li>
<li>in Windows: ipconfig</li>
<li><strong>DNS(Domain Name Service:域名服务器)</strong><blockquote>
<p>无论何时给出什么名称，域名服务器都会相应所给名称的相应IP地址。 当有任何数据从我们的计算机出来时，DNS会将此名称解析为相应的IP地址</p>
</blockquote>
</li>
</ul>
<p><font color=red>command:nslookup – 查询DNS服务器以获得给定名称的IP地址</font><br>ex:peiruliu.cn –&gt; IP address由DNS解析<br>检查电脑能否访问该网站: ping website’s IP. if there is no loss, it is correct<br>Ping can check whether two computers are reachable<br><img src="/2022/01/03/Network-note-from-nesco-academy/IP.png" alt="img"></p>
<p>trace the route from my computer to the peiruliu.cn:tracerout<br><img src="/2022/01/03/Network-note-from-nesco-academy/trace.png" alt="img"></p>
<h2 id="4-Basic-of-Router"><a href="#4-Basic-of-Router" class="headerlink" title="4 Basic of Router"></a>4 Basic of Router</h2><p>In this session, we will be able to </p>
<ul>
<li>Know the basic of routers</li>
<li>Understand how to connect two different LAN using router therorectically</li>
<li>Understand the difference between switch and router</li>
</ul>
<h3 id="4-1-Switch"><a href="#4-1-Switch" class="headerlink" title="4.1  Switch"></a>4.1  Switch</h3><blockquote>
<p>A switch is a networking hardware that connects devices on computer network to establish a local area network(LAN)</p>
</blockquote>
<p><font color=red> In the conputer network, each device is identified with the help of Ip and MAC address.</font></p>
<p>The switch has the memory, so the switch can store the MAC address table in it memory</p>
<p><strong>What is MAC address table?</strong><br>In MAC address table, 会将设备的MAC address与连接到switch上的端口对应起来(video:23)</p>
<h3 id="4-2-Router"><a href="#4-2-Router" class="headerlink" title="4.2  Router"></a>4.2  Router</h3><blockquote>
<p>A router is a networking device that forwards data packet between computer newtorks<br>A router is connected to at least two networks, commonly two LANs or WANs or a LAN and its ISP’s network</p>
</blockquote>
<p>When we say computer networks, they are two different LAN.</p>
<p><strong>The differences between switch and router</strong></p>
<ul>
<li>The switch can connect two computers that belong to the same LAN, while the router can connect two computers that belong to the different LANs.</li>
<li>The router is a layer 3 device(network layer), while the switch is a 2 layer device(data linke layer)</li>
<li>Router stores routing table</li>
<li>Switch(Half/Full Duplex), Router(Full Duplex)</li>
</ul>
<h4 id="4-2-1-Working-of-Router"><a href="#4-2-1-Working-of-Router" class="headerlink" title="4.2.1 Working of Router"></a>4.2.1 Working of Router</h4><p><img src="/2022/01/03/Network-note-from-nesco-academy/router.png" alt="img"><br>The router has two interfaces, one interface connect one LAN, and another interface connect another LAN. </p>
<ol>
<li>The computer send data and 10.0.0.10 receive it.</li>
<li>The transfer the data to another interface(192.168.1.10)</li>
<li>Finally, the data will be received by the destination</li>
</ol>
<h2 id="5-Basics-of-Bridge"><a href="#5-Basics-of-Bridge" class="headerlink" title="5 Basics of Bridge"></a>5 Basics of Bridge</h2><ul>
<li>Understand the basics of bridge</li>
<li>Know the types of bridge</li>
<li>Understand the working of bridge</li>
<li>Understand the difference between router and bridge</li>
</ul>
<h3 id="5-1-Concept-of-the-Bridge"><a href="#5-1-Concept-of-the-Bridge" class="headerlink" title="5.1  Concept of the Bridge"></a>5.1  Concept of the Bridge</h3><ol>
<li>Bridge=Repeater+Functionality of reading MAC address</li>
<li>It is a layer 2 device</li>
<li>It is also used for interconnecting two LANs on the <font color=red>same protocol</font></li>
<li>It is also a two port device</li>
</ol>
<h3 id="5-2-Types-of-Bridges"><a href="#5-2-Types-of-Bridges" class="headerlink" title="5.2  Types of Bridges"></a>5.2  Types of Bridges</h3><ul>
<li>Transparent Bridges<blockquote>
<ul>
<li>These are the bridge in which the stations are completely unaware of the bridge’s existance</li>
<li>Reconfiguration of the station is unnecessary even if the bridge is added or removed from network(unlike the router: we used to give the IP address of the interface as the default gateway for all stations or PCs)</li>
</ul>
</blockquote>
</li>
<li>Sourece Routing Bridges<blockquote>
<ul>
<li>In these bridges, routing operation is performed by source station and the frame specified which route to follow  ??</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="5-3-Working-or-Bridges"><a href="#5-3-Working-or-Bridges" class="headerlink" title="5.3 Working or Bridges"></a>5.3 Working or Bridges</h2><p><img src="/2022/01/03/Network-note-from-nesco-academy/bridge.png" alt="img"></p>
<p><strong>The differences between the Bridge and Router</strong><br><font size=4></p>
<table>
<thead>
<tr>
<th>Bridge</th>
<th><small>Router</th>
</tr>
</thead>
<tbody><tr>
<td><small>connect two LANs running in the same protocols</td>
<td><small>connect two LANs running on the different protocols</td>
</tr>
<tr>
<td><small>second layer device(process MAC address)</td>
<td><small>third layer device(process IP address)</td>
</tr>
</tbody></table>
<h2 id="6-Network-Devices"><a href="#6-Network-Devices" class="headerlink" title="6 Network Devices"></a>6 Network Devices</h2><ol>
<li><p>Repeater</p>
<blockquote>
<p>First layer device, operate in the Physical layer. It just regenerates the signal in a single LAN network</p>
</blockquote>
</li>
<li><p>Hub</p>
<blockquote>
<p>First layer device(LAN device). Shortcoming: It will broadcast whatever it receives</p>
</blockquote>
</li>
<li><p>Switch</p>
<blockquote>
<p>Second layer device(LAN devcie). Connecting two devices which belong to the same single LAN.<br>Unlike the Hub, it can send the data to the exact receiver</p>
</blockquote>
</li>
<li><p>Bridge</p>
<blockquote>
<p>Second layer device. It can also regenerates the signal</p>
</blockquote>
</li>
<li><p>Router</p>
<blockquote>
<p>Third layer device. Make decisions based on the IP address</p>
</blockquote>
</li>
<li><p>Multi-layer switch(Layer 3 swithc)</p>
<blockquote>
<p>can be the switch as well as the router</p>
</blockquote>
</li>
<li><p>Brouter</p>
<blockquote>
<p>Combination of router and bridge</p>
</blockquote>
</li>
<li><p>Modem</p>
</li>
<li><p>Firewall(Security Device)</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
</search>
