<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C plus plus note</title>
    <url>/2022/01/03/C-plus-plus/</url>
    <content><![CDATA[<h1 id="C-basic"><a href="#C-basic" class="headerlink" title="C++ basic"></a>C++ basic</h1><font face=Times New Roman size=4.8>
OP三大原则
封装（encapsulation): bundle data and methods dealing with these data together in an object. Hide the details of the data and the action. Restrict only access to the publicized methods.
数据在里面，操作在外面

<p>继承，多态性</p>
<p>同一个对象之间可以互相访问私有的成员变量类的成员变量在类的所有函数中都能使用成员变量不在类里面，而是在每一个类的对象中 (成员变量-&gt;7:28)<br>声明只是告诉别人有一个这个东西，而不知道在哪里函数是属于类的，不是属于对象的private是对类来说的，而不是对象</p>
<p>C++的OOP特性只在源代码级别存在， 编译之后就不是OOP的东西了。 编译成.o(二进制可执行程序后，丧失了C++所有的特性）</p>
<p>friends:申明别人（别的类，别的函数，别的类里面的某个函数）是你的盆友——&gt;她可以访问你的private的东西（访问限制那一节）</p>
<p>default argument只能在.h文件里操作，不能在.cpp文件里操作<br>default argument 是编译时的事， 不是运行时的事<br>本地变量与成员变量（field)</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。<br>只要创建对象，构造函数就会被调用<br>最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。对于示例2的代码，在栈上创建对象可以写作Student stu()或Student stu，在堆上创建对象可以写作Student *pstu = new Student()或Student *pstu = new Student，它们都会调用构造函数 Student()。<br>构造函数使用初始化列表：成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关<br>初始化 const 成员变量的唯一方法就是使用初始化列表</p>
<p>析构函数没有返回类型，不能有参数<br>被析构之前（对象被消灭的时候），析构函数会被调用<br>当一个对象离开scope时，析构函数会被调用。析构意味着该对象拥有的空间要被收回<br>The only evidence for a destructor call is the closing brace of the scope that surrounds the object</p>
<p>this是一个指针，类型是这个函数所属的那个类的对象的指针<br>在成员函数中用到成员变量时，实际上所有的成员变量都可以看做前面有this-&gt;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">int</span> initiallen);</span><br><span class="line">    ~Line;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>(<span class="keyword">int</span> initiallen)&#123;</span><br><span class="line">    len=initiallen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~<span class="built_in">Line</span>()&#123;</span><br><span class="line">    cout&lt;&lt; Line::~Line&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;<span class="comment">// 此时10.0会传给len</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>The complier allocates all the storage for a scope at the opening brace of that scope</p>
<p>The constructor call does not happen until the sequence point where the object is defined</p>
<p>一个对象没有做过构造，不能被析构</p>
<p>A default constructor is one that can be called with no arguments</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>&#123;</span></span><br><span class="line">             <span class="keyword">float</span> f;</span><br><span class="line">             <span class="keyword">int</span> i;</span><br><span class="line">             <span class="built_in">Y</span>(<span class="keyword">int</span> a);  <span class="comment">//constructor</span></span><br><span class="line">&#125;</span><br><span class="line">Y y1[]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>), <span class="built_in">Y</span>(<span class="number">2</span>), <span class="built_in">Y</span>(<span class="number">3</span>)&#125;;</span><br><span class="line">Y y1[<span class="number">2</span>]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>)&#125;   <span class="comment">//wrong</span></span><br></pre></td></tr></table></figure>

<h2 id="New-and-Delete"><a href="#New-and-Delete" class="headerlink" title="New and Delete"></a>New and Delete</h2><p>Dynamic memory allocation<br>new<br>new int;<br>new Stash;<br>1、如果Stash是一个类，会分配Stash对象的空间<br>2、分配完空间，会调用其构造函数：构造函数一定会被调用，当这个对象被创建的时候。 无论这个变量是本地变量还是堆里面的变量<br>3、该运算符的结果是地址<br>new int[10];  //分配10个int的空间</p>
<p>delete<br>delete p;<br>delete [] p;</p>
<p>如果new的时候带有[],则delete的时候也需要 []. 使用delete p所指对象时， 析构函数先被调用， 空间再被收回</p>
<p>new is the way to allocate memory as a program runs. Pointers become the only access to that memory</p>
<p>delete enables you to return memory to the memory poll when you are finished with it</p>
<h3 id="Dynamic-Arrays"><a href="#Dynamic-Arrays" class="headerlink" title="Dynamic Arrays"></a>Dynamic Arrays</h3><p>int * psome=new int [10]<br>the new operator returns the address of the first element of the blcok</p>
<p>delete []psome<br>The presence of the brackets tells the program that it should free the whole array, not just the element;<br>不带[], 空间会被回收，但是析构只有第一个会被调用一次。 没有[]，代表psome所指的地方只有一个对象，所以只需要调用它所指的地址上的对象的析构就可</p>
<p>Student *q=new<br>Student();<br>delete q;<br>1、调用Student(因为知道q的类型，所以知道需要调用Student的析构，而不是其他的析构）的析构<br>2、回收空间</p>
<p>Student *r=new;<br>Student[10];<br>delete r;   //它认为r所指的是一个，会调用r所指的那个对象的析构， 只析构一个，后面9个没管<br>delete []r;</p>
<p>int *a=new int[10]<br>a++<br>delete []a  //运行错误， 找不到</p>
<p>It’s safe to apply delete to the null pointer</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;p=<span class="keyword">new</span> <span class="keyword">int</span>;i=<span class="number">0</span>; cout&lt;&lt;<span class="string">&quot;A::A()&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;<span class="keyword">if</span>(p) <span class="keyword">delete</span> p; cout&lt;&lt;<span class="string">&quot;A::~A()&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//if(p)最好加，也可以不加</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>-&gt;i=i;&#125;  </span><br><span class="line">    <span class="comment">// i=i不对，就近原则，这里的i把成员变量中的i覆盖了  注意这里this的用法， this-&gt;i指的是调用的那个函数的对象的i </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hello&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;p=<span class="keyword">new</span> <span class="keyword">int</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Access-limitation"><a href="#Access-limitation" class="headerlink" title="Access limitation"></a>Access limitation</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//int *p;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;i=<span class="number">0</span>; cout&lt;&lt;<span class="string">&quot;A::A()&quot;</span>&lt;&lt; endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>-&gt;i=i;&#125;  <span class="comment">// i=i不对，就近原则，这里的i把成员变量中的i覆盖了  注意这里this的用法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hello&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(A *q)</span></span>&#123;cout&lt;&lt;q-&gt;i&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *p=<span class="keyword">new</span> A[<span class="number">10</span>];</span><br><span class="line">    A b;</span><br><span class="line">    b.<span class="built_in">set</span>(<span class="number">100</span>);</span><br><span class="line">    p[<span class="number">0</span>].<span class="built_in">g</span>(&amp;b);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同一个类的对象之间可以互相访问私有的成员变量</p>
<h2 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h2><p>Can declare a global function as a friend, as well as a member function of another class, or even an entire class, as a friend</p>
<p>class defaults to private<br>struct defaults to public<br>the only difference between class and struct</p>
<p>if the class is too easy, we can use struct, but seldom use it </p>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">p</span>(<span class="number">0</span>)&#123;&#125;  <span class="comment">//intialise list:在构造函数的（）后加冒号， 冒号里写成员变量的名字，（）给出初始值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> xa=<span class="number">0.0</span>, <span class="keyword">float</span> ya=<span class="number">0.0</span>):<span class="built_in">y</span>(ya),<span class="built_in">x</span>(xa)&#123;&#125;</span><br><span class="line">    <span class="comment">//这两个变量的初始化早于构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyClass</span> &#123;</span></span><br><span class="line">    <span class="built_in">CMyClass</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">int</span> m_x;</span><br><span class="line">    <span class="keyword">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CMyClass::<span class="built_in">CMyClass</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">m_y</span>(y), <span class="built_in">m_x</span>(m_y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你可能以为上面的代码将会首先做 m_y=y，然后做 m_x=m_y，最后它们有相同的值。但是编译器先初始化 m_x，然后是 m_y,，因为它们是按这样的顺序声明的。结果是 m_x 将有一个不可预测的值。有两种方法避免它，一个是总是按照你希望它们被初始化的顺序声明成员，第二个是，如果你决定使用初始化列表，总是按照它们声明的顺序罗列这些成员。这将有助于消除混淆。</p>
<p>order of initialization is order of declaration<br>-Not the order in the list<br>-Destoryed in the reverse order</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>类型名 &amp; 引用名 = 某变量名, 并将其初始化为引用某个变量<br>int n=4;<br>int &amp; r=n  // r引用了n, r的类型是int &amp;<br>某个变量的引用等价于这个变量，相当于这个变量的别名</p>
<p>定义引用时一定要将其初始化为某个变量<br>引用初始化后，一直引用该变量，不会再引用其他变量<br>引用只能引用变量， 不能引用常量和表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> a=<span class="number">4</span>, b=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> &amp;r1=a;</span><br><span class="line"><span class="keyword">double</span> &amp;r2=r1; <span class="comment">//r2也引用了a</span></span><br><span class="line">r2=<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; a&lt;&lt;endl; <span class="comment">//输出10</span></span><br><span class="line">r1=b; <span class="comment">//用b对r1进行赋值</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">//a=b</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n1,n2;</span><br><span class="line"><span class="built_in">swap</span>(n1,n2);  <span class="comment">// swap n1 and n2</span></span><br></pre></td></tr></table></figure>

<p>引用作为函数的返回值<br><font color=red>注意：不要返回局部变量的引用<br>用法：函数调用作为左值</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">10</span>;  <span class="comment">//静态变量存在全局区，数据在程序结束后释放</span></span><br><span class="line">    <span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;ref=<span class="built_in">test</span>() <span class="comment">//相当于int &amp;ref=a;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref= &quot;</span>&lt;&lt; ref &lt;&lt; endl;<span class="comment">//结果正确，因为编译器做了保留</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref= &quot;</span>&lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//第二次结果错误，因为a的内存已经释放</span></span><br><span class="line">    <span class="keyword">int</span> &amp;ref2=<span class="built_in">test2</span>();</span><br><span class="line">    <span class="built_in">test2</span>()=<span class="number">1000</span>;  <span class="comment">//相当于做了a=1000的操作</span></span><br><span class="line">    cout&lt;&lt; ref2&lt;&lt; endl; <span class="comment">//result:1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">Setvalue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> n;&#125;  <span class="comment">//函数的返回值引用了n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Setvalue</span>()=<span class="number">40</span>;   <span class="comment">//等价于对n进行赋值</span></span><br><span class="line">    cout&lt;&lt; n;       <span class="comment">//n=40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义引用时，前面加const关键字，即为常引用<br>int n;<br>const int &amp;r=n;  r的类型为const int &amp;<br>r=200; //编译错，不能试图通过r修改n的值<br>n=300; 没问题<br>不能通过常引用修改其引用的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">(<span class="keyword">int</span> *x)</span></span>&#123;</span><br><span class="line">    (*x)++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;  <span class="comment">//safe</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="comment">//return q; //error,因为q是本地变量，这个函数结束后就不存在了；</span></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//safe, x lives outside this scope</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(&amp;x);</span><br><span class="line">    <span class="built_in">g</span>(a);</span><br><span class="line">    <span class="built_in">h</span>()=<span class="number">16</span>;  <span class="comment">//一个函数的返回结果是一个reference,reference可以做左值。x=16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h3><p><font color=red>引用的本质在C++内部实现是一个指针常量.指针常量指的是指针指向不能更改</font><br>可以转换为：int *const ref=&amp;a</p>
<h2 id="References-as-class-memebers"><a href="#References-as-class-memebers" class="headerlink" title="References as class memebers"></a>References as class memebers</h2><p>Declared without initial value<br>Must be initialized using constructor initializer list</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> &amp; m_y;</span><br><span class="line">        <span class="built_in">X</span>(<span class="keyword">int</span> &amp;a);</span><br><span class="line">&#125;</span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span> &amp;a):<span class="built_in">m_y</span>(a)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>作用：常量引用主要用来修饰形参，防止误操作<br>在函数形参列表中，可以加const修饰形参，防止形参改变实参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> class_size=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> finalgrade[class_size]; <span class="comment">//OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = x;</span><br><span class="line"><span class="keyword">double</span> classAverage[size]; <span class="comment">//error 编译时不知道size的值 //运行时才知道，所以不知道要分配多少空间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cip;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">3</span>;</span><br><span class="line">ip=&amp;ci;</span><br><span class="line">cip=&amp;ci;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> s2[]=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s1在代码段中，s2在堆栈中<br>程序运行后，变量放在三种不同的地方。本地变量放在堆栈中，new出来的东西在heap中，全局变量在全局数据区中；全局变量中的常量：hello world等在代码段里面，代码段不可写</p>
<p>如果一个函数return 的是一个const，无所谓，因为常数本身不能做左值。如果return的是一个指针并且是const,那个这个指针不能做左值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">f4</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> j = <span class="built_in">f3</span>();<span class="comment">//work fine</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="built_in">f4</span>(); <span class="comment">//but this works fine too</span></span><br><span class="line">    <span class="comment">//因为f4()是一个值，值可以赋给k, 并不是试图改变f4的返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当const在函数名前面的时候修饰的是函数返回值。</p>
<p>当const在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。 </p>
<p>const Currency the_raise(42, 38);<br>整个对象是一个const,对象中的值不能被修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="comment">//定义时也需要加上const</span></span><br><span class="line">    day++;<span class="comment">// Error modifies data member</span></span><br><span class="line">    <span class="built_in">set_day</span>(<span class="number">12</span>);   <span class="comment">//Error calls non_const memeber</span></span><br><span class="line">    <span class="keyword">return</span> day; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数名后面加const， 说明函数成员变量不能被修改<br>const 对象不能引用非const的成员函数<br>非const的对象可以引用const的成员函数<br>const的对象只能引用const的成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		_a = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a2</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">a3</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//_a = 30;  //报错 const的函数不能对其数据成员进行修改操作。</span></span><br><span class="line">		<span class="keyword">return</span> _a;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">a1</span>();</span><br><span class="line">	a.<span class="built_in">a2</span>(); <span class="comment">//非const的对象可以引用const的成员函数</span></span><br><span class="line">	a.<span class="built_in">a3</span>();</span><br><span class="line">	<span class="keyword">const</span> A b;</span><br><span class="line">	b.<span class="built_in">a1</span>(); <span class="comment">//报错 const的对象，不能引用非const的成员函数</span></span><br><span class="line">	b.<span class="built_in">a2</span>();<span class="comment">//const的对象只能引用const的成员函数</span></span><br><span class="line">	b.<span class="built_in">a3</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f()&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//actually:void f(A* this)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;cout&lt;&lt;<span class="string">&quot;f() const&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//it is void f(const A* this)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.<span class="built_in">f</span>();  <span class="comment">//result: printf f() const;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if the member is const, have to be initialized in initializer list of the constructor.<br>成员变量是const, 不能用该成员变量做数组的size. 在前面加上static就可以<br>enum{size=100};<br>int array[size];  /ok</p>
<p>在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
<p>友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; &amp;<span class="title">same</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;s1, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;s2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[j])&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(s2[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;<span class="keyword">int</span>&gt;::iterator it1=temp.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">typename</span> vector&lt;<span class="keyword">int</span>&gt;::iterator it2;</span><br><span class="line">    <span class="keyword">for</span>(;it1&lt;temp.<span class="built_in">end</span>()<span class="number">-1</span>;it1++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(it2=it1+<span class="number">1</span>;it2&lt;temp.<span class="built_in">end</span>();it2++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it1==*it2)&#123;</span><br><span class="line">                temp.<span class="built_in">erase</span>(it2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;temp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;temp=&quot;</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">98</span>,<span class="number">23</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;v3=<span class="built_in">same</span>(v1,v2);</span><br><span class="line">    temp.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v3.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;v3=&quot;</span>&lt;&lt;v3[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v3.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;temp2=&quot;</span>&lt;&lt;temp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果函数的返回值是用引用并且前面有const, 只是代表其所赋的值，不能改变它。如上：不能通过v3改变temp，但temp本身可以改变。</p>
<h2 id="Inline-function"><a href="#Inline-function" class="headerlink" title="Inline function"></a>Inline function</h2><p>overhead for a function call<br>函数的参数和本地变量地位一样，都是在堆栈中<br>overhead for a function call<br>1、Push parameters<br>2、Push return address<br>3、Prepare return values<br>4、Pop all pushed</p>
<p>An inline function is expanded in place, like a preprocessor macro, so the overhead of the function call is eliminated.<br>将函数的代码嵌入到调它的地方去， 但依旧保持函数的独立性（有自己的空间，本地变量只在函数的scope中有效…)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> ++x&#125;;</span><br></pre></td></tr></table></figure>
<p>在.h和.cpp中都必须repeat<br>Repeat inline keyword at declaration and definition<br>在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。<br>引入内联函数的目的是为了解决程序中函数调用的效率问题，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p>
<p>1.在内联函数内不允许使用循环语句和开关语句；<br>2.内联函数的定义必须出现在内联函数第一次调用之前；<br>3.类结构中所在的类说明内部定义的函数是内联函数。<br>使用：网易云（不是很懂）<br>在a.h中需要写<br>inline int plusOne(int x);<br>inline int plusOne(int x){return ++x};<br>在a.cpp中写入：<br>inline int plusOne(int x){return ++x};<br>在main.cpp中使用：f(10);<br>在一个函数前加上inline后，这个函数的定义不再是定义，而是申明，因此不需要a.cpp，只需要a.h</p>
<p>如果函数很小：2-3行，值得做成inline.如果函数在循环中被频繁调用，也值得做成inline</p>
<p>不inline:超过20行，递归</p>
<h2 id="Overloaded-Operator"><a href="#Overloaded-Operator" class="headerlink" title="Overloaded Operator"></a>Overloaded Operator</h2><p>operators must be overloaded on a class or enumeration type<br>重载的运算符必须保持原有的操作数的个数<br>优先级不能改变</p>
<p>Just a function with an operator name<br>-Use the operator keyboard as a prefi to name operator *(…)</p>
<p>can be member function<br>const String String::operator + (const String &amp;that)<br>String 这个类有个成员函数叫operator, 这时：已经有一个hidden parameter, this-&gt;, 因此参数表中出现一个that就可以了。 返回结果是const String</p>
<p>can be global function<br>const String::operator+(const String &amp;r, const String &amp; l)<br>参数表是两个参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Interger</span>(<span class="keyword">int</span> n=<span class="number">0</span>):<span class="built_in">i</span>(n)&#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp;n)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Integer</span>(i+n.i);<span class="comment">//第三个const-&gt;this-&gt;i不能改变</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Integer x(1), y(5), z;<br>x+y=&gt;x.operator+(y)  operator+是一个函数名<br>运算符左边的算子叫receiver, 决定用哪个加。可能有integer的+， float的+….， 左边的receiver是一个integer的对象，于是用integer里面的成员加来做加</p>
<p>z=x+3 √<br>3不能直接用，实际上是用构造函数把3构造成一个integer的对象， 将这个对象给x的operator+做加法运算</p>
<p>z=3+y; ×   receiver决定了operator用哪个，除非y有一种方法把自己变成整数（后面会学）</p>
<p>For unary operators(unary-，(取负)，！etc)member functions require no arguments<br>const Integer operator-()const{<br>    return Integer(-i);<br>}<br>z=-x  // z.operator=(x.operator-());<br>用自己的值取负后制造出一个新的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp; lhs, <span class="keyword">const</span> Integer &amp; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Integer <span class="keyword">operator</span>+(<span class="keyword">const</span> Integer &amp; lhs, <span class="keyword">const</span> Integer &amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Integer</span>(lhs.i+rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>z=3+y √<br>把3变成一个integer<br>z=3+7 √<br>3+7=10， 用构造函数将10构造出一个对象，给z<br>Members vs Free functions<br>unary operators should be members<br>=,(),[],-&gt;, -&gt;* must be members<br>assignment operators should be members<br>All other binary operators as non-members</p>
<h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h2><p>Suppose you need a list of X and a list of Y<br>The lists would use similar code<br>They differ by the type stored in the list</p>
<p>两种template:class, function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">swap function <span class="keyword">for</span> two <span class="keyword">int</span> arguments</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if we want to swap Person, float…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;x, T &amp;y)</span></span>&#123;</span><br><span class="line">    T temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The template keyword introduces the template<br>The class T specifies a parameterized type name<br><font color=red>Inside the tempate, use T as a type name</font><br>template 下面是什么，什么就是template. 该例子中，template下面是swap function, 所以swap是template<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">3</span>; <span class="keyword">int</span> j=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">swap</span>(i,j);    <span class="comment">//use explicit int swap</span></span><br><span class="line">folat k=<span class="number">4.5</span>; <span class="keyword">float</span> m=<span class="number">3.7</span></span><br><span class="line"><span class="built_in">swap</span>(k,m)    <span class="comment">//use instanstiate float swap</span></span><br><span class="line">std::string <span class="built_in">s</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="function">std::string <span class="title">t</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(s,t);</span><br></pre></td></tr></table></figure></p>
<p>Only exact match on types is used<br>模板中的参数是两个T，意味着完全相同的类型</p>
<p>Overloading rules<br>Check first for unique function match<br>Then check for unique function template match<br>Then do overloading on functions</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">T</span><span class="params">(<span class="keyword">float</span> i, <span class="keyword">float</span> k)</span></span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t, T u)</span></span>&#123;&#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>,<span class="number">2.0</span>);   <span class="comment">//error?</span></span><br></pre></td></tr></table></figure>
<p>The complier deduces the template type from the actual arguments passed into the function</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;&#125;</span><br><span class="line">foo&lt;<span class="keyword">int</span>&gt;();  <span class="comment">//Type T is int</span></span><br><span class="line">foo&lt;<span class="keyword">float</span>&gt;();    <span class="comment">//Type T is float</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span>);</span><br><span class="line">    ~<span class="built_in">Vector</span>();</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector&amp;);</span><br><span class="line">    Vector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Vector&amp;);</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_elements;</span><br><span class="line">    <span class="keyword">int</span> m_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Vector<int> v1(100);  100是构造函数的参数<br>Vector<Complex> v2(256);<br>v1[20]=10;<br>v2[20]=v1[20];</p>
<h3 id="普通函数与函数模板的区别"><a href="#普通函数与函数模板的区别" class="headerlink" title="普通函数与函数模板的区别"></a>普通函数与函数模板的区别</h3><p>1、普通函数调用可以发生隐式类型转换（如形参是int，实参是char, 将char转换为int传入）<br>2、函数模板，用自动类型转换，无法发生隐式类型转换<br>3、函数模板，用显示指定类型，可以发生隐式类型转换<br>建议使用显示类型的方式使用模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> m_age, string m_name):<span class="built_in">age</span>(m_age),<span class="built_in">name</span>(m_name)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getname</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T &amp;a, T &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用具体化Person的版本实现代码，具体优化调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.<span class="built_in">getage</span>()==p2.<span class="built_in">getage</span>() &amp;&amp; p1.<span class="built_in">getname</span>()==p2.<span class="built_in">getname</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>,<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">bool</span> res=<span class="built_in">compare</span>(p1, p2);</span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1==p2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1!=p2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 利用具体化模板，可以解决自定义类型的通用化</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一个类的interface指的是对外公开的那些部分<br>当继承一个类时，需要对那个类进行扩充</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>():<span class="built_in">width</span>(<span class="number">0</span>), <span class="built_in">height</span>(<span class="number">0</span>)&#123;cout&lt;&lt;<span class="string">&quot;Shape():&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> h):<span class="built_in">width</span>(w), <span class="built_in">height</span>(h)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getheight</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::getheight</span><span class="params">(<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">    height=h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shape::getWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    width=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rec</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rec</span>():<span class="built_in">Shape</span>(<span class="number">3</span>,<span class="number">4</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Rec R;</span><br><span class="line">    R.<span class="built_in">getWidth</span>(<span class="number">4</span>);</span><br><span class="line">    R.<span class="built_in">getheight</span>(<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;R.<span class="built_in">Area</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Exeception"><a href="#Exeception" class="headerlink" title="Exeception"></a>Exeception</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch1=s[<span class="number">100</span>];</span><br><span class="line">        cout&lt;&lt;ch1&lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(execption e)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[1]out of bound!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch2=s.<span class="built_in">at</span>(<span class="number">100</span>);</span><br><span class="line">        cout&lt;&lt;ch2&lt;&lt; endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(execption &amp;e)&#123; <span class="comment">//exception类位于&lt;exception&gt;头文件中</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[2]out of bound!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 try 没有捕获到异常，输出了一个没有意义的字符（垃圾值）。因为[ ]不会检查下标越界，不会抛出异常，所以即使有错误，try 也检测不到。换句话说，发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到。所谓抛出异常，就是明确地告诉程序发生了什么错误。</p>
<p>第二个 try 检测到了异常，并交给 catch 处理，执行 catch 中的语句。需要说明的是，异常一旦抛出，会立刻被 try 检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是第 17 行的 at() 函数，它后面的 cout 语句就不会再被执行，所以看不到它的输出。</p>
<p>检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了；即使 catch 语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了</p>
<h3 id="发生异常的位置"><a href="#发生异常的位置" class="headerlink" title="发生异常的位置"></a>发生异常的位置</h3><p>异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被 try 检测到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Unknown Exception&quot;</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[1]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[2]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        cout&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result: Unknown Exception</span></span><br></pre></td></tr></table></figure>

<p>func() 在 try 块中被调用，它抛出的异常会被 try 检测到，进而被 catch 捕获。从运行结果可以看出，func() 中的 cout 和 try 中的 cout 都没有被执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Unknown Exception&quot;</span>;  <span class="comment">//抛出异常</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[1]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func_inner</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[2]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">func_outer</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;[3]This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> <span class="keyword">char</span>* &amp;e)&#123;</span><br><span class="line">        cout&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result: Unknown Exception</span></span><br></pre></td></tr></table></figure>

<p><font color=red>发生异常后，程序的执行流会沿着函数的调用链往前回退，直到遇见 try 才停止。在这个回退过程中，调用链中剩下的代码（所有函数中未被执行的代码）都会被跳过，没有执行的机会了。(不是很懂) </font></p>
<h3 id="C-异常类型以及多级catch匹配"><a href="#C-异常类型以及多级catch匹配" class="headerlink" title="C++异常类型以及多级catch匹配"></a>C++异常类型以及多级catch匹配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的语句</span></span><br><span class="line">&#125;<span class="built_in"><span class="keyword">catch</span></span>(exceptionType variable)&#123;</span><br><span class="line">    <span class="comment">// 处理异常的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exceptionType是异常类型。异常类型可以是 int、char、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型<br>variable是变量，用来接受异常信息</p>
<p><a href="http://c.biancheng.net/view/2331.html">http://c.biancheng.net/view/2331.html</a></p>
<p>我们可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据）。</p>
<p>总起来说，catch 和真正的函数调用相比，多了一个「在运行阶段将实参和形参匹配」的过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base&#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Derived</span>();  <span class="comment">//抛出自己的异常类型，实际上是创建一个Derived类型的匿名对象</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;This statement will not be executed.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: int&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">char</span> *)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: cahr *&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(Base)&#123;  <span class="comment">//匹配成功（向上转型）</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: Base&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="built_in"><span class="keyword">catch</span></span>(Derived)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Exception type: Derived&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中，我们定义了一个基类 Base，又从 Base 派生类出了 Derived。抛出异常时，我们创建了一个 Derived 类的匿名对象，也就是说，异常的类型是 Derived。</p>
<p>我们期望的是，异常被catch(Derived)捕获，但是从输出结果可以看出，异常提前被catch(Base)捕获了，这说明 catch 在匹配异常类型时发生了向上转型（Upcasting）</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL的六大组件：容器，算法，迭代器，仿函数，适配器，空间配置器<br>1、容器：各种数据结构，如Lvector,list, deque, set, map等用来存储数据<br>2、算法：各种常用的算法，如：sort, find, copy, for_each等<br>3、迭代器：扮演了容器和算法之间的胶合剂<br>4、仿函数：行为类似函数，可作为算法的某种策略<br>5、适配器：一种用来修饰容器或者仿函数或迭代器接口的东西<br>6、空间配置器：负责空间的配置与管理</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string Name, <span class="keyword">int</span> Age):<span class="built_in">name</span>(Name), <span class="built_in">age</span>(Age)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Person::getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;name:&quot;&lt;&lt;(*it).name&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;age: &quot;&lt;&lt;(*it).age&lt;&lt;endl;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name: &quot;</span>&lt;&lt;it-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="string">&quot;age: &quot;</span>&lt;&lt;it-&gt;<span class="built_in">getAge</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 存放自定义数据类型的指针<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string Name, <span class="keyword">int</span> Age):<span class="built_in">name</span>(Name), <span class="built_in">age</span>(Age)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Person::getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Person::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;Person *&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">    v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;Person *&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;name:&quot;&lt;&lt;(**it).getName()&lt;&lt;&#x27; &#x27;&lt;&lt;&quot;age: &quot;&lt;&lt;(**it).getAge()&lt;&lt;endl;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;name: &quot;</span>&lt;&lt;(*it)-&gt;<span class="built_in">getName</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="string">&quot;age: &quot;</span>&lt;&lt;(*it)-&gt;<span class="built_in">getAge</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> vector与普通数组的区别：数组是静态空间，而vector可以动态扩展</p>
<p> 动态扩展并不是在原空间之后续接新的空间，而是找更大的内存空间，然后将元数据拷贝到新空间，释放原空间</p>
<h3 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h3><p>vector<T> v;  默认构造函数<br>vector(v.begin(), v.end()); 将v[begin(), end())区间内的元素拷贝给本身。注意前闭后开<br>vector(n, elem)   将n个elem拷贝给本身<br>vector(const vector &amp;vec)  拷贝构造函数</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome To My Website</title>
    <url>/2022/01/03/Welcome-To-My-Website-1/</url>
    <content><![CDATA[<font face=Times New Roman>
<font size=5>
This is my personal website and it is my first time to try to do it. Usually, I will share and write articals about SDE and other areas in computer science that I am interested. I am a green hand in CS area, if someone read my article and find mistakes, welcome to tell me and we can discuss it together.
]]></content>
      <tags>
        <tag>-Welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Interview Note</title>
    <url>/2022/01/05/Network-Interview-Note/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>C Plus Plus Interview Note</title>
    <url>/2022/01/05/C-Plus-Plus-Interview-Note/</url>
    <content><![CDATA[<font size=4>
<font face="Times New Roman">

<h1 id="1-Const"><a href="#1-Const" class="headerlink" title="1  Const"></a>1  Const</h1><h2 id="1-1-const的含义"><a href="#1-1-const的含义" class="headerlink" title="1.1 const的含义"></a>1.1 const的含义</h2><p>如果变量前有const， 则该变量不能被改变</p>
<h2 id="1-2-const的作用"><a href="#1-2-const的作用" class="headerlink" title="1.2 const的作用"></a>1.2 const的作用</h2><ul>
<li>防止编程中犯错：改变不应该改变的量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i=<span class="number">100</span>;</span><br><span class="line">i=<span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure></li>
<li>定义常量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li>节约内存空间<ul>
<li>const 与define的区别<ol>
<li>define 在预编译阶段展开， const在运行阶段使用</li>
<li>define没有类型。const有具体类型， 在编译时会进行类型检查。</li>
<li>const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-const对象默认为文件的局部变量"><a href="#1-3-const对象默认为文件的局部变量" class="headerlink" title="1.3 const对象默认为文件的局部变量"></a>1.3 const对象默认为文件的局部变量</h2><p>在file2中访问file1的变量，在file2的变量前加extern即可。<br>而const声明的变量只是当前文件中的局部变量</p>
<ul>
<li><p>访问未被const修饰的变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file 1.cpp</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">//file 2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure></li>
<li><p>被const修饰的变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file 1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//file 2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>conclude: 由const定义的变量在定义时需要被初始化; 如果想在其他文件中使用该量，则需要在定义时声明extern</p>
</blockquote>
<h2 id="1-4-const与指针"><a href="#1-4-const与指针" class="headerlink" title="1.4 const与指针"></a>1.4 const与指针</h2><p>有三种类型</p>
<h3 id="1-4-1-指向常量的指针"><a href="#1-4-1-指向常量的指针" class="headerlink" title="1.4.1 指向常量的指针"></a>1.4.1 指向常量的指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;x;  <span class="comment">//声明时可以不初始化：const int p -&gt; legal</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p=&amp;x;</span><br></pre></td></tr></table></figure>
<p>p指向一个int 类型的变量，不能改变该变量的值。但是可以改变p指向的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y=<span class="number">10</span>;</span><br><span class="line">p=&amp;y <span class="comment">//legal</span></span><br><span class="line">*p=<span class="number">20</span> <span class="comment">//illegal</span></span><br><span class="line">y=<span class="number">20</span> <span class="comment">//legal because y is not const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> y=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *p=&amp;y; <span class="comment">//illegal because we have declare y is const-&gt; y cannot be modified, if we use int *p-&gt; we can use the *p to change y&#x27;s value, we violate that &quot;y cannot be modified&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p=&amp;y; <span class="comment">//legal</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-常指针"><a href="#1-4-2-常指针" class="headerlink" title="1.4.2 常指针"></a>1.4.2 常指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;x;</span><br></pre></td></tr></table></figure>
<p>p指向一个int类型的变量，可以通过*p改变该变量的值。但是不能改变p所指的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*p=<span class="number">10</span>  <span class="comment">//legal</span></span><br><span class="line"><span class="keyword">int</span> y=<span class="number">3</span>;</span><br><span class="line">p=&amp;y    <span class="comment">//illegal</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="1-4-3-指向常量的常指针"><a href="#1-4-3-指向常量的常指针" class="headerlink" title="1.4.3  指向常量的常指针"></a>1.4.3  指向常量的常指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p=&amp;x</span><br></pre></td></tr></table></figure>
<p>既不能更改p所指的对象，也不能通过*p改变变量x的值<br>如果是二维指针：<br><img src="/const_pointer.png" alt="img"></p>
<blockquote>
<p>conclude:  const影响的是离它最近的量</p>
</blockquote>
<ol>
<li>若const前面没有*(int * const p=&amp;x),则const影响的是该指针变量, 该变量的值不能改变，即不能指向其他的变量（ex:int * const p=&amp;x,p只能指向x)</li>
<li>若const前有一个*(const int * p)， 则const影响的是*p, 即该指针可以指向其他的变量，但不能通过 *p改变其所指的当前变量的值</li>
</ol>
<h2 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h2>]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
